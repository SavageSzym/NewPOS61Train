/** 
* NP6majorversion=6.1.17
* NP6build=B193
* NP6scriptversion=2.58.02
* CreationDate=20.07.2011
*
* Copyright (c) 2009-2010 McDonald's IT Europe
*
* BusinessComponentsLocal.nps
* This NPS file implements Local Business Componentes.
*
* SOTEC History Changes
*
* Version		Date			Name			Detail Description
* 2.50.00		25.01.2010	Olga Illenseer		Take over from 6.1.16 Scripts	
* 2.50.02		05.02.2010	Mihai Secareanu	Add two functions for working with workflows
* 2.50.03		19.02.2010	Mihai Secareanu	Add e-cash function for France ( update e-cash, initialisation offline) .Add support for executing remote BC on more then one register.
* 2.52.00		08.04.2010 	Mihai Secareanu	Test if telequipt is loaded in opratorLogin ( not call for coins amount if not needed);	Add dual point support; add  function that are no more included in CSL layer 
* 2.53.00		30.04.2010 	Mihai Secaraenu
*			19.04.2010	Mihai Secareanu	FR  e-cash  changes  get the post list from waystation
* 			20.04.2010	Olga Illenseer		Implement PosDoOrderBumpFromORBJS
*			21.04.2010 	Mihai Secareanu	Do not alowed the overring of stored order (order that are not yet tendered)
*  			22.04.2010 	Mihai Secareanu	change PosDoOperatiorLoginJS: postransfer  operation type 12 and test for coin dispenser state
*			27.04.2010 	Mihai Secareanu	PosDoTenderJS call for PosDoTender  change according to ACSP7973411 ( in order to show the skim warning)
* 2.53.01		11.05.2010	MihaiSecareanu	add IsActualSaleQuantityPositive  ( ACSP8164964)
* 2.54.00		28.05.2010	Mihai Secareanu	implement posdodiscount();
*										optimise the calling of poscreatereport for getting the businessdate, storeid and operator id.
* 2.54.03		25.06.2010 	Mihai Secareanu										
*			22.06.2010	Olga Illenseer		Add PT dual point settings
* 2.54.04		29.07.2010	Mihai Secareanu	loading PT custom script for e-cash and cod
* 2.54.06		08.07.2010	Mihai Secareanu	update PosDoDiscount so it that it will display the discouted amount in tender screen.(ACSP8272219)
* 2.55.00		29.07.2010 	Mihai Secareanu
*			16.07.2010 	Mihai Secareanu 	Family pack Voucher implementation	
*			20.07.2010 	Mihai Secareanu 	Do not alow to log cashier on ot/cs or cs mode.
*			28.07.2010 	Mihai Secaraenu 	Add family pack voucher trnasofmration to PosDoTotalJs		
* 2.55.02		18.08.2010	Olga Illenseer		Update PosDoOperatorLoginJS, we return now true if it's successfull
*
* 2.56.02		07.10.2010	Mihai Secareanu	correct e-cash cashless call for FR add a new session parameter to know if the e-cash was initialized offline
* 2.56.05		08.11.2010	Mihai Secareanu	add call for onLogoutFinalize; add NL family voucher grill preserve
* 2.56.07		07.12.2010	Mihai Secareanu	add skip authorization in case of promo of special products
										update the place from where the PromoItemAuthorityLevel, PromoItemAuthorityLimits , DiscountAuthorityLevel, DiscountAuthorityLimits are read
* 2.56.10		11.01.2011	Mihai Secareanu
* 			06.01.2011 	Mihai Secareanu 	small fix for family voucher ( the same index was used twice in nested for s
*2.56.16		18.03.2011	Mihai Secareanu
*		 							 	family voucher  change to not open grill screen if there is no grill instruction; customize the messages on voucher dialog
*		  			 					not print end of day reports if the printer is not available (parameter checkPrinterStatus) 
* 2.56.18		11.04.2011	Mihai Secareanu
*										read solve choice parameter from store-db
*										SaleProductsAndPromoJS
*			23.05.2011	Olga Illenseer		Set selcted button value for refundDialogSelection=2
*2.56.21		30.05.2011	Mihai Secareanu		Add 6.1.16 implementation for reduction receipt, family voucher next and previous button
			01.06.2011	Mihai Secareanu		Implement a function that will toggle between all foreign currency
* 2.56.22		09.06.2011	Mihai Secareanu		Pos Open/Close issue in Ireland			
* 2.58.00		18.06.2011	Mihai Secareanu		add PosDoOperatorLogout and  change PosDoOperatorLogoutJS according to NP6.1 RC13 sample scripts
*									update PosDoSaleSizeJS according to Np6.1.17 RC16 release notes
*/
  
 
const TENDER_SCREEN_NBR="53";
const STORE_SCREEN_NBR="51";

const TENDER_SCREEN_NBR_DE="153";
const STORE_SCREEN_NBR_DE="151";

const BYPREVIEW_SCREEN_NBR="9998";

executeScript("BCCoinDispenser.nps",true);
executeScript("BCCashless.nps",true);
executeScript("BCTandem.nps",true);
executeScript("BCCOD.nps",true);
executeScript("BCEvents.nps",true);
//6.1.16
//executeScript("everestEMU.nps",true);
executeScript("telequipt.nps",true);
//for UK 
executeScript("BCPrinterStatus.nps",true);

/*global variables for reading RFm configuration*/
var xmlStoreDB = new XML(API.getStoredb());
var xmlPosDB = new XML(API.getPosdb());
var Country = (xmlStoreDB.StoreDB.StoreProfile.StoreDetails.Country).toUpperCase();

executeScript("eurecs.nps",true);

if(Country =="PT")
{
	var ptEcashScript = xmlStoreDB.Configurations.Configuration.(@type=="Store.wide").Section.(@name="PT_NPScripts").Parameter.(@name=="ecash").@value; 
	var ptCodScript = xmlStoreDB.Configurations.Configuration.(@type=="Store.wide").Section.(@name=="PT_NPScripts").Parameter.(@name=="cod").@value; 
	API.dbg("PT scripts "+ptEcashScript + " "+ptCodScript);
	if(ptEcashScript+"" !="")
	{
		executeScript(ptEcashScript,true);
	}
	else
	{
		executeScript("PTEcash.nps",true);
	}
	if(ptCodScript+"" !="")
	{
		executeScript(ptCodScript,true);
	}
	executeScript("PTCOD.nps",true);
}





/* global variables for familypack implementation  */
//will have the qunatity of each type of value meals for the current tranzaction
var familyPackKM = 0;
var familyPackSM = 0;
var familyPackVM = 0;
//will contain the number of discount type 1 or 2 for the current trazaction
var familyPackDiscount1TC = 0;
var familyPackDiscount2TC = 0;
//will contain the amount of discount type 1 or 2 
var familyPackDiscount1Amount = new BigDecimal(0.00);
var familyPackDiscount2Amount = new BigDecimal(0.00);

//global info
var StoreID_Local = 0;
var outputBuffer 	= null;
var PosID_Local = "";
var businessDate_Local = "";
var operatorID_Local="0";
var runGetConfig_Local = true; //poscreate report for getting the storeID, posID and operator ID should be run just at start up or after the operatior is changed

var familyVoucherArr = new Array();
var familyPack_ProductsArr = new Array();
var familyPack_GrillConfigArr = new Array();
var familyPackVoucherActive = null;

/*
Authoer: Mihai Secareanu
Description: this function will load the tvoucher definition for NL family pack promotion
*/
function familyVoucher_loadConfig()
{
	/*memory structure:
	Voucher
		-name
		-picture
		- componentArr (array)
	Component
		-qty
		-targetQtyDivideBy
		-codes (array)
		-foundQty
		
		
	Code
		-code
		-translate
	
	
	*/
	//to do get the xml 
	if(File.exists("../POSDATA/familyvouchers.xml") ==false)
	{
		PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_NoFile"));
		return true;
	}
	var	file = new File("../POSDATA/familyvouchers.xml");
	file.open("r");
	
	var configtext = file.read();
	file.close();
	var xmlFamilyVoucher = new XML(configtext);
	API.dbg("Sotec family pack voucher xml "+ xmlFamilyVoucher);
	var numberofVouchers = xmlFamilyVoucher.vouchers.voucher.length();
	for( var i=0; i<numberofVouchers ;i++)
	{
		var item = xmlFamilyVoucher.vouchers.voucher[i];
		var voucherObj=new Object();
		voucherObj.name= item.@name;
		voucherObj.picture= item.@picture;
		voucherObj.componentArr =new Array();
		
		numberOfComponents = item.component.length();
		for(var j=0; j<numberOfComponents ; j++)
		{
			componentItem = item.component[j];
			var componentObj = new Object();
			componentObj.qty = componentItem.@quantity;
			componentObj.targetQtyDivideBy = 1; //default 1
			if(componentItem.@targetQtyDivideBy !=null &&  componentItem.@targetQtyDivideBy+"" !="")
			{
				componentObj.targetQtyDivideBy =componentItem.@targetQtyDivideBy;
			}
			componentObj.foundQTY = 0;
			componentObj.codes= new Array();
			numberOfCodes = componentItem.item.length();
			for(var t=0; t<numberOfCodes ; t++)
			{
				product = componentItem.item[t];
				var productObj = new Object();
				productObj.code = product.@plu;
				productObj.translate = xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu).@pluTo;
				var node = xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu);
				if(node.length() > 1)
				{
					productObj.translateGrillConfigCode = node.(@voucherName == voucherObj.name).@translategrillConfigCode;
				}
				else
				{
					productObj.translateGrillConfigCode = xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu).@translategrillConfigCode;
				}
				productObj.grillConfigCode = product.@grillConfigCode;
				if(xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu).length() > 1)
				{
					//check fo the voucher name also
					productObj.translate = xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu && @voucherName==voucherObj.name).@pluTo;
				}
				else
				{
					productObj.translate = xmlFamilyVoucher.itemConversions.item.(@pluFrom == product.@plu).@pluTo;
				}
				componentObj.codes[t] = productObj;
			}
			voucherObj.componentArr[j] = componentObj;
		}
		familyVoucherArr[i]=voucherObj;
	}
	
	familyVoucher_loadTranslationTable()
	familyVoucher_loadGrillConfiguration();
	//API.dbg("Sotec test "+ familyVoucherArr[0].name +" "+familyVoucherArr[1].componentArr[1].qty)
	//API.dbg("Sotec test "+ familyVoucherArr[0].componentArr[0].codes[0].code + " "+familyVoucherArr[0].componentArr[0].codes[0].translate)	
}

/*
Authoer: Mihai Secareanu
Description: this function will load the tranlation table for nl family pack voucher
*/
function familyVoucher_loadTranslationTable()
{
	if(File.exists("../POSDATA/familyvouchers.xml") ==false)
	{
		PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_NoFile"));
		return true;
	}
	var file = new File("../POSDATA/familyvouchers.xml");
	file.open("r");
	var configtext = file.read();
	file.close();
	//API.dbg("Sotec text "+ configtext);
	var xmlFamilyVoucher = new XML(configtext);
	var numberofProducts = xmlFamilyVoucher.itemConversions.item.length();
	for( var i=0; i<numberofProducts;i++)
	{
		var item = xmlFamilyVoucher.itemConversions.item[i];
		var product=new Object();
		product.code= item.@pluFrom;
		product.translation= item.@pluTo;
		product.voucher= item.@voucherName;
		product.grillConfigCode= item.@grillConfigCode;
		product.translategrillConfigCode= item.@translategrillConfigCode;
		familyPack_ProductsArr[i]= product;
	}
}


/*
Author: Mihai Secareanu 
Description: this function will load the grillIndex configuration
*/
function familyVoucher_loadGrillConfiguration()
{
	if(File.exists("../POSDATA/familyvouchers.xml") ==false)
	{
		PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_NoFile"));
		return true;
	}
	var file = new File("../POSDATA/familyvouchers.xml");
	file.open("r");
	var configtext = file.read();
	file.close();
	//API.dbg("Sotec text "+ configtext);
	var xmlFamilyVoucher = new XML(configtext);
	var numberofGrillConfig = xmlFamilyVoucher.grillIndexInfo.grillConfig.length();
	for(var i=0; i<numberofGrillConfig;i++)
	{
		var grillConfiguration = new Object();
		grillConfiguration.code =  xmlFamilyVoucher.grillIndexInfo.grillConfig[i].@code;
		grillConfiguration.arrIndex = new Array();
		var numberofGrillIndex = xmlFamilyVoucher.grillIndexInfo.grillConfig[i].index.length();
		for(var j=0; j<numberofGrillIndex;j++)
		{
			var grillIndex = new Object();
			grillIndex.value= xmlFamilyVoucher.grillIndexInfo.grillConfig[i].index[j].@value;
			grillIndex.productCode = xmlFamilyVoucher.grillIndexInfo.grillConfig[i].index[j].@productCode;
			grillConfiguration.arrIndex[j]=grillIndex;
		}
		familyPack_GrillConfigArr[i]= grillConfiguration; 
	}
}

/*
Author: Mihai Secareanu 
Description: This function will search for the grill index
*/
function getGrillIndex(valueMealCode, componentCode, ocupiedIndexes)
{
	//API.dbg("getGrillIndex "+valueMealCode+ " "+componentCode+ " " +ocupiedIndexes);
	//the componentCode is either a component or a choice
	for(var i=0; i<familyPack_GrillConfigArr.length; i++)
	{
		//API.dbg("familyPack_GrillConfigArr[i].code "+familyPack_GrillConfigArr[i].code);
		if(familyPack_GrillConfigArr[i].code == valueMealCode) //the code was found
		{
			for(var j=0; j<familyPack_GrillConfigArr[i].arrIndex.length; j++)
			{
				if(searchIndex(componentCode,familyPack_GrillConfigArr[i].arrIndex[j].productCode) ==true)
				{
					//the candidate code was found now we must check to see if is already ocupied
					if(testOcupied(familyPack_GrillConfigArr[i].arrIndex[j].value, ocupiedIndexes) == true)
					{
							//is ocupied we must find the next one available
							var index = Number(familyPack_GrillConfigArr[i].arrIndex[j].value)+1;
							while(testOcupied(index,ocupiedIndexes))
							{
								index++;
							}
							//API.dbg("index after while "+index);
							return index;
					}
					else
					{
						return componentCode,familyPack_GrillConfigArr[i].arrIndex[j].value;
					}
					break; //exit second if
				}
			}
			break; //exit first if
		}
	}
	//API.dbg("return 0 ");
	return 0;  //default
	
	
	
	
}
//search for the compoentCode into productsCode (string of productCode separated by | )
function searchIndex(componentCode,productsCode)
{
	//API.dbg("searchIndex " + componentCode+ " " +productsCode);
	var arrProductCode = productsCode.split("|");
	for(var i=0; i< arrProductCode.length; i++)
	{
		if(arrProductCode[i] == componentCode)
		{
			//API.dbg("searchIndex return true");
			return true;
		}
	}
	//API.dbg("searchIndex return false");
	return false;
}

//search for the index into ocupiedIndexes (string of indexes separated by | )
function testOcupied(index,ocupiedIndexes)
{
	if(ocupiedIndexes =="")
	{
		//API.dbg("first testOcupied return false");
		return false;
	}
	//API.dbg(" testOcupied " + index+ " " +ocupiedIndexes);
	var arrOcupiedIndexes = ocupiedIndexes.split("|");
	for(var i=0; i< arrOcupiedIndexes.length; i++)
	{
		API.dbg(arrOcupiedIndexes[i] +" "+  Number(index));
		if((arrOcupiedIndexes[i]+"").length>=1 && Number(arrOcupiedIndexes[i]) == Number(index))
		{
			//API.dbg("testOcupied return true");
			return true;
		}
	}
	//API.dbg("testOcupied return false");
	return false;
}
/*not used
delete grill lines
*/
function familyVoucher_ClearGrill()
{
	PosSetSession("FamilyPack_Voucher","true");
	var hlp 			= new BusinessObjectHelper;
	currView = hlp.getCurrentView();

	view= new XML(currView);
	var clear = false;
	for(var i=0; i < view.ItemView.length(); i++)
	{
		view= new XML(currView);
		for(var j =0; j<familyPack_ProductsArr.length;j++)
		{
			//search in the sale view
			if(familyPack_ProductsArr[j].code  == view.ItemView[i].productCode)
			{
				//test to see if is having any grill instruction
				if(view.ItemView.(itemCode == view.ItemView[i].itemCode && isGrillLine == "true").length()>0)
				{
					//remove grill line if any
					PosDoSelIndex(i);
					PosDoGrillStart("");
					PosClearGrill();
					PosDoGrillEnd("3");
					clear =true;
					i=0;
					break;
				}
			}
			else 
			{
				clear =false;
			}
		}
		if(clear ==true)
		{
			var hlp 			= new BusinessObjectHelper;
			currView = hlp.getCurrentView();
			view = new XML(currView);
		}		
	}	
}


function checkOpenChoice()
{
	var hlp 			= new BusinessObjectHelper;
	currView = hlp.getCurrentView();
	view= new XML(currView);
	
	for(var i=0; i<view.ItemView.length();i++)
	{
		if(view.ItemView[i].productType=="4" && Number(view.ItemView.(itemCode == view.ItemView[i].itemCode)[0].quantity) !=0)
		{
			return true;
		}
	}
	return false;
}

//global variables that will store the available images and values  for available vouchers
var voucherImagesOptions = new Array();
var voucherValuesOptions = new Array();

/*
Author: Mihai Secareanu
Description: this function will add previous and next button to the NewPos6.1 select dialog
*/
function familyVoucher_FormatDialogBox()
{
	var numberOfOptions = voucherImagesOptions.length;
	
	//temporary arrays that will contain the available vocuhers and the buttons previous, next and cancel
	var tempVoucherImagesOptions = new Array();
	var tempVoucherValuesOptions = new Array();
	
	var images ="";
	var values="";
	var cnt =1;
	var isFirstPage= true;
	var indexPageStart = 1; 
	var j=0;
	for(var i=0; i<=numberOfOptions; i++)
	{
	    if(isFirstPage ==true) //we need to know if is first page because this page will have just next and cancel buton (no previous button)
		{
			if(cnt<=8 && i <(numberOfOptions -1)) //first 8 position are available to vouchers
			{
				tempVoucherImagesOptions[j] = voucherImagesOptions[i];
				tempVoucherValuesOptions[j] = voucherValuesOptions[i];
				cnt++;
			}
			else  //position 9 and 10 have next and cancel button
			{
				isFirstPage =false; 
				if((i+1) > numberOfOptions) //no need to show the button next	
				{			//and no more vouchers available
					tempVoucherImagesOptions[j] = "cancel.png";
					tempVoucherValuesOptions[j] = "-1";
					
				}
				else if((i+1) == numberOfOptions) //no need to show the button next	
				{   //just one vmore oucher available 
					tempVoucherImagesOptions[j] = voucherImagesOptions[i];
					tempVoucherValuesOptions[j] = voucherValuesOptions[i];
					
					tempVoucherImagesOptions[j+1] = "cancel.png";
					tempVoucherValuesOptions[j+1] = "-1";
					i++;
					j= j+1;
					
				}
				else  //more then one voucher available , show enxt and cancel button
				{
					tempVoucherImagesOptions[j] = "voucher_next.png";
					tempVoucherValuesOptions[j] = Number(j+2)+"N";

					tempVoucherImagesOptions[j+1] = "cancel.png";
					tempVoucherValuesOptions[j+1] = "-1";
					
					tempVoucherImagesOptions[j+2] = voucherImagesOptions[i];
					tempVoucherValuesOptions[j+2] = voucherValuesOptions[i];
					j=j+2;
				}
				cnt=1; // reset the counter again for the next page
				indexPageStart = 0; 
			}
		}
		else //this is not the first page
		{
			if(cnt<=6 && i <(numberOfOptions -1))  //first 7 position are available for voucher  (the first position was already added in the first page if, that's why we count to 6) 
			{
				tempVoucherImagesOptions[j] = voucherImagesOptions[i];
				tempVoucherValuesOptions[j] = voucherValuesOptions[i];
				cnt++;
			}
			else  //check to see what previous, next button must be showed
			{
				if((i+1) > numberOfOptions) //no need to show the button next	
				{		
					tempVoucherImagesOptions[j] = "voucher_previous.png";
					tempVoucherValuesOptions[j] = indexPageStart+"P";
					
					tempVoucherImagesOptions[j+1] = "cancel.png";
					tempVoucherValuesOptions[j+1] = "-1";
					j=j+1;
				}
				else if((i+1) == numberOfOptions) //show previous and cancel button
				{
					//there is one more voucher available
					tempVoucherImagesOptions[j] = voucherImagesOptions[i];
					tempVoucherValuesOptions[j] = voucherValuesOptions[i];
				
					tempVoucherImagesOptions[j+1] = "voucher_previous.png";
					tempVoucherValuesOptions[j+1]= indexPageStart+"P";
					
					tempVoucherImagesOptions[j+2] = "cancel.png";
					tempVoucherValuesOptions[j+2] = "-1";
					i++;
					j=j+2;
				}
				else  //there are more then one voucher available, show previous, next cancel button
				{
					tempVoucherImagesOptions[j] = "voucher_previous.png";
					tempVoucherValuesOptions[j]= indexPageStart+"P";
	
					tempVoucherImagesOptions[j+1] = "voucher_next.png";
					tempVoucherValuesOptions[j+1]= Number(j+3)+"N";
	
					tempVoucherImagesOptions[j+2] = "cancel.png";
					tempVoucherValuesOptions[j+2] = "-1";
					
					tempVoucherImagesOptions[j+3] = voucherImagesOptions[i];
					tempVoucherValuesOptions[j+3] = voucherValuesOptions[i];
					j=j+3;
					indexPageStart = j-3-cnt;
				}
				cnt=1; // reset the counter again for the next page
			}
		}
		j++;
		
	}
	//copy the resulted arrays that contains previous next and cancel buttons to the global arrays
	voucherImagesOptions = tempVoucherImagesOptions;
	voucherValuesOptions = tempVoucherValuesOptions;
}


/*Author Mihai Secareanu
This function will show a dialog box with a page for available voucher
startIndex is the start location in the global array  from each the dialog will be generated
*/
function familyVoucher_ShowDialog(startIndex)
{
	if(voucherImagesOptions.length <=1) //just cancel button
	{
		return false;
	}

	var availableVouchersImage="";
	var availableVouchersValue="";
	for(var i=startIndex; i< (Number(startIndex)+9); i++)
	{
		if(voucherImagesOptions[i] != undefined)
		{
			availableVouchersImage += voucherImagesOptions[i];
			availableVouchersValue += voucherValuesOptions[i];
			if( voucherValuesOptions[i] != -1) //is not the cancel button which is the last button 
			{
				availableVouchersImage +="|";
				availableVouchersValue +="|";
			}
			
		}
	}
	if(voucherImagesOptions[i] != undefined)
	{
		availableVouchersImage += voucherImagesOptions[Number(startIndex)+9];
		availableVouchersValue += voucherValuesOptions[Number(startIndex)+9];
	}
	
	var familyVoucher_title = "Family Vouchers";
	if(API.getLocalMsg("MSG_FamilyPackVoucher_Title") != "MSG_FamilyPackVoucher_Title")
	{
		familyVoucher_title = API.getLocalMsg("MSG_FamilyPackVoucher_Title");
	}
	var familyVoucher_select = "Select one voucher";
	if(API.getLocalMsg("MSG_FamilyPackVoucher_Select") != "MSG_FamilyPackVoucher_Select")
	{
		familyVoucher_select = API.getLocalMsg("MSG_FamilyPackVoucher_Select");
	}
	
	return PosItemSelection(availableVouchersImage, availableVouchersValue, familyVoucher_title, familyVoucher_select);
}

/*
Authoer: Mihai Secareanu
Description: this function will detect any possible voucher.  
*/
function familyVoucher_AvailableVouchers()
{
	//you can initiate a transformation only if all the choice are  selected
	//API.DbgMessageBox(PosCheckChoice("null"));
	//API.DbgMessageBox(PosCheckChoice(""));
	if(checkOpenChoice() ==true)  //check for open choice PosCheckChoice is not working
	{
		PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_OPEN_CHOICE"));
		return true;
	}
	
	var hlp 			= new BusinessObjectHelper;
	currView = hlp.getCurrentView();

	view= new XML(currView);

	//get the voucher
	var availableVouchersImage="";
	var availableVouchersValue="";
	var cnt = 0;
	voucherImagesOptions = new Array();
    voucherValuesOptions = new Array();	
	for(var i=0; i< familyVoucherArr.length; i++)
	{		
		var addVoucher =true;
		//get the component
		for(var j =0 ; j< familyVoucherArr[i].componentArr.length; j++)
		{
			
			var componentQTY = familyVoucherArr[i].componentArr[j].qty;
			familyVoucherArr[i].componentArr[j].foundQTY =0; //reset found qty necessary for the second step
			for(var u=0; u< view.ItemView.length(); u++)
			{
				if(Number(view.ItemView[u].level) !=0)
				{
					continue;
				}
				productCode = view.ItemView[u].productCode;
				//get the products
				for(var t= 0 ; t < familyVoucherArr[i].componentArr[j].codes.length; t++)
				{
					if(Number(familyVoucherArr[i].componentArr[j].codes[t].code) == Number(productCode))
					{
						
						familyVoucherArr[i].componentArr[j].foundQTY +=view.ItemView[u].quantity - view.ItemView[u].quantityPromo;
						break;
					}
				}
			}
			
			if(componentQTY > familyVoucherArr[i].componentArr[j].foundQTY)
			{
				addVoucher =false;  
				break; //no need to continue for this voucher
			}
		}
		if(addVoucher ==true)
		{
			voucherImagesOptions[cnt] = familyVoucherArr[i].picture;
			voucherValuesOptions[cnt] = Number(i+1);
			cnt++;
		}
	}
	/*
	if(availableVouchersValue =="")
	{
		if(PosCheckSessionProperty("FamilyPack_Voucher_Executed","true") ==true)
		{
			PosSetSessionProperty("FamilyPack_Voucher_Executed","false");
			//PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_Warning"));
		}
		return true;
	}*/
	API.dbg("Family pack  menu "+voucherImagesOptions + " values "+ voucherValuesOptions);
	//add the previous next and cancel buttons
	familyVoucher_FormatDialogBox();
	
	
	
		
	if(familyVoucher_ShowDialog(0) == true)  //show the first dialog box
	{
		var ctx = new SessionContext;
		var selectedOption = ctx.get("SelectedButtonValue");
		//API.dbg("Family pack selected option "+Number(selectedOption));
		
		while(selectedOption.search("P") != -1 || selectedOption.search("N") !=-1) //if is a next or a previous button
		{
			familyVoucher_ShowDialog(selectedOption.substr(0,selectedOption.length-1));
			selectedOption = ctx.get("SelectedButtonValue");
		}
	
		//API.dbg("Family pack selected option "+Number(selectedOption));
		if(Number(selectedOption) > 0)
		{
			 familyVoucher_transformView(selectedOption);
		}
		else  //cancel button was pressed
		{
			if(PosCheckSessionProperty("FamilyPack_Voucher_Executed","true") ==true)
			{
				PosSetSessionProperty("FamilyPack_Voucher_Executed","false");
				//PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_Warning"));
			}
		}		
	}
	return true;
}



/*
Authoer: Mihai Secareanu
Description: this function will delete all the void lines (included value meals) from the sale view.  
*/
function delete_voidLines()
{
	var hlp 			= new BusinessObjectHelper;
	currView = hlp.getCurrentView();
	view= new XML(currView);
	var qty =0;
	for(var i= 0; i< view.ItemView.length(); i++)  
	{
		if(view.ItemView[i].level =="0")  //we get the quantity just for simple products or value meals.
		{
			qty =  view.ItemView[i].quantity;
		}
		
		if(qty == "0")
		{
			delete view.ItemView[i];
			i--; //the lcurrent enelement is deleted so the next element will have the current index
		}
	}
	
	//set the new sale view
	hlp.setCurrentView(view);
	PosRefreshSalePanel();
}
/*
Author: Mihai Secareanu 
Date: 12.072010
Description: This function will be used for NL Family Voucher. It will void some items and sell voucher ( reduced) products that will replace the voided items
*/
function familyVoucher_transformView(selectedOption)
{
	PosSetSessionProperty("FamilyPack_Voucher","true");  //no authentication for reduction
	PosSetSessionProperty("FamilyPack_Voucher_Executed","true");
	//delete all voided lines. They can cause issues durring the transformation 
	delete_voidLines();
	
	var hlp 			= new BusinessObjectHelper;
	currView = hlp.getCurrentView();
	view= new XML(currView);
	
	//get the components of the voucher
	selectedOption = selectedOption-1;
	for(var j =0 ; j< familyVoucherArr[selectedOption].componentArr.length; j++)
	{
		currView = hlp.getCurrentView();
		view= new XML(currView);
		var componentQTY = familyVoucherArr[selectedOption].componentArr[j].qty;
		var targetQtyDivideBy = familyVoucherArr[selectedOption].componentArr[j].targetQtyDivideBy;
		var indexes= new Array();
		var storeProducts = new Array();   //open choice for  translated products
		var storeProducts1 = new Array();  //partial open choice that are available from products that have a QTY lower than requested
		var storeProducts2 = new Array();   //open choice that will remain for items that are not transformed
		var translatedGrillArray = new Array();  //partial open grill components and choice
		
		var index_Counter =0;
		var storeProducts_Counter =0;
		var storeProducts1_Counter =0;
		var storeProducts2_Counter =0;
		var translatedGrillIndex_Counter=0;
		var productsLevelZero = view.ItemView.(level=="0" && quantity!="0");
				
		//this two variable will retain the ocupied tab index for the source and translated product
		var ocupiedIndexes="";
		var translate_ocupiedIndexes="";
		for(var u=0; u< productsLevelZero.length(); u++)
		{
			found =false; //set just if we made a translation to a voucher product
			if((Number(productsLevelZero[u].quantity)- Number(productsLevelZero[u].quantityPromo))>0) //no need to test it if the qty is 0
			{
				productCode = productsLevelZero[u].productCode;

				//quantity that can be transformed to voucher product
				var qtyCurrent = Number(productsLevelZero[u].quantity)- Number(productsLevelZero[u].quantityPromo);
				//get the products
				for(var t= 0 ; t < familyVoucherArr[selectedOption].componentArr[j].codes.length; t++)
				{
					if(Number(familyVoucherArr[selectedOption].componentArr[j].codes[t].code) == Number(productCode))
					{   //we found the product 
						//get all products that have the same itemCode	
					    var currItemCode =  productsLevelZero[u].itemCode;
					    var allProducts = view.ItemView.(Number(itemCode)==Number(currItemCode));
					   
					    
						var translate_valueMealCode = familyVoucherArr[selectedOption].componentArr[j].codes[t].translateGrillConfigCode; //get the coresponding  grill code of the  translated value meal voucher
						var valueMealCode = familyVoucherArr[selectedOption].componentArr[j].codes[t].grillConfigCode;  //get the coresponding grill code for  the  value meal 
						var translated_grillIndex = getGrillIndex(translate_valueMealCode, productCode, translate_ocupiedIndexes); //get the grill tab  index in the voucher grill screen
												
					    API.dbg("pas 1");					
					   if(componentQTY > qtyCurrent) // insuficient QTY found 
					   {   //there are two cases:  when 1 product will be translated into anothe product (targetQTYDivideBy is 1);  2 n products will be translated into just one product  (targetQTYDivideBy =n)
							//the currentQTY can be equal or less then targetQTyDivedeBy 
							API.dbg("pas 2");	
							if(targetQtyDivideBy == qtyCurrent)  //we can make the translation ; works just if targetQTYDivideBy is 1 or 2 and mcomponentQTY is 1 or 2. 
							{
								API.dbg("pas 3");	
								//found =true;
								var saleQTY = new BigDecimal(qtyCurrent);
								saleQTY = saleQTY.divide(targetQtyDivideBy,6); 
								
								var otherProd = new Object();
								
								otherProd.qty=Number(saleQTY);
								
								var qty = saleQTY;
								
								otherProd.prodCode =  familyVoucherArr[selectedOption].componentArr[j].codes[t].translate;
								storeProducts[storeProducts_Counter] = otherProd;
								otherProd.grillInstructionsArray = new Array();
								otherProd.choiceArray = new Array();
								storeProducts_Counter++;
								
								//PosDoSaleJS(familyVoucherArr[selectedOption].componentArr[j].codes[t].translate);
								//PosDoQuantum(-1);
								
								//save the line that will be replaced
								var objProd = new Object();
								objProd.grillInstructionsArray = new Array();
								objProd.choiceArray = new Array();
								objProd.lineView = u;
								objProd.prodCode = productCode;
								objProd.remainingQTY=0;
								objProd.promoQTY = productsLevelZero[u].quantityPromo; 
								indexes[index_Counter] = objProd; //the line in the sale view
								index_Counter++;
								
								//get the grill lines if any for the main product (this is in case the product is not a value meal )
								for(var line = 1; line<allProducts.length(); line++)
								{
									if(allProducts[line].isGrillLine == "true")
									{
										var stop = qty;
										if(Number(targetQtyDivideBy) != 2)
										{
											stop =1;
										}
										for(var x = 0; x < stop; x++)  //if we have two components with the same qrill instruction
										{
											var grillObject = new Object();
											var translate_grillLength = otherProd.grillInstructionsArray.length;
											grillObject.productCode = allProducts[line].productCode;
											grillObject.grilledQuantity = allProducts[line].grilledQuantity;
											grillObject.specialModifiers = allProducts[line].specialModifiers;
											//the voucher product may be a value meal in this case we need to get the tabindex								
											grillObject.translate_grillTabIndexProd =  Number(translated_grillIndex)+Number(x);
											translate_ocupiedIndexes +=translated_grillIndex+"|";											
											otherProd.grillInstructionsArray[translate_grillLength] = grillObject;
										}
										
										//for the source product
										var grillObject = new Object();
										var grillLength = objProd.grillInstructionsArray.length;
										grillObject.productCode = allProducts[line].productCode;
										grillObject.grilledQuantity = allProducts[line].grilledQuantity;
										grillObject.specialModifiers = allProducts[line].specialModifiers;
										//if si having direct instruction then is not a value meal 
										grillObject.grillTabIndexProd = 0;
										objProd.grillInstructionsArray[grillLength] = grillObject;
									}
									else
									{
										break;
									}
								}
								API.dbg("pas 4");	
								var grillLength = objProd.grillInstructionsArray.length;
								var t_grillLength = otherProd.grillInstructionsArray.length;
								//if the product is a value meal then we may have some grill instruction of its components
								for(var line = 1; line<allProducts.length(); line++)
								{
									if(allProducts[line].level != "0" && allProducts[line].prodAction =="0" && allProducts[line].isGrillLine =="false") //it's a component
									{
										//get all gril instructions
										var tab = Number(getGrillIndex(valueMealCode, allProducts[line].productCode, ocupiedIndexes));
										var translate_tab =  Number(getGrillIndex(translate_valueMealCode, allProducts[line].productCode, translate_ocupiedIndexes));
										for(var grillLine = line+1; grillLine < allProducts.length(); grillLine++)
										{
											
											if(allProducts[grillLine].isGrillLine == "true")
											{
												var stop = qty * allProducts[line];
												if(Number(targetQtyDivideBy) != 2)
												{
													stop =allProducts[line].quantity;
												}
												for(var x = 0; x < stop; x++)  //if we have two component with the same qrill instruction
												{
													t_grillLength = otherProd.grillInstructionsArray.length;
													var grillObject = new Object();
													grillObject.productCode = allProducts[grillLine].productCode;
													grillObject.grilledQuantity = allProducts[grillLine].grilledQuantity;
													grillObject.specialModifiers = allProducts[grillLine].specialModifiers;
													
													//get the grill tab index of the transformed product
													grillObject.translate_grillTabIndexProd =Number(translate_tab)+Number(x);
													translate_ocupiedIndexes += grillObject.translate_grillTabIndexProd+"|";	
													otherProd.grillInstructionsArray[t_grillLength] = grillObject;
												}	
												
												//for the source product
												for(var x = 0; x < allProducts[line].quantity; x++)  //if we have two component with the same qrill instruction
												{
													grillLength = objProd.grillInstructionsArray.length;
													
													var grillObject = new Object();
													grillObject.productCode = allProducts[grillLine].productCode;
													grillObject.grilledQuantity = allProducts[grillLine].grilledQuantity;
													grillObject.specialModifiers = allProducts[grillLine].specialModifiers;
													
													//get the grill tab index
													grillObject.grillTabIndexProd = Number(tab)+Number(x);
													ocupiedIndexes += grillObject.grillTabIndexProd+"|";
													//get the grill tab index of the transformed product
													objProd.grillInstructionsArray[grillLength] = grillObject;	
												}	
											}
											else
											{
												break;
											}
										}
										
									}
								}
								API.dbg("pas 5");
															
								//for the translated product we may have some additional grill instruction and grill component instruction
								t_grillLength = otherProd.grillInstructionsArray.length;
								for(var i=0; i<translatedGrillIndex_Counter; i++)
								{
									var parrentCode= translatedGrillArray[i].parrentCode; //get the porduct that has the grill instruction
									if(i>=1) //maybe we have the grill instruction for the same product
									{
										if(translatedGrillArray[i].parrentCode == translatedGrillArray[i-1].parrentCode && translatedGrillArray[i].second == translatedGrillArray[i-1].second ) //second is needd in case we have two qty of the same product
										{
											translatedGrillArray[i].translate_grillTabIndexProd = translatedGrillArray[i-1].translate_grillTabIndexProd
										}
									}
									if(translatedGrillArray[i].translate_grillTabIndexProd =="-1") //if the grill tab index is still not set search for it
									{
										translatedGrillArray[i].translate_grillTabIndexProd = getGrillIndex(translate_valueMealCode, parrentCode, translate_ocupiedIndexes);
										translate_ocupiedIndexes += translatedGrillArray[i]. translate_grillTabIndexProd+"|";
									}
									
									otherProd.grillInstructionsArray[t_grillLength+i] = translatedGrillArray[i]; 
								}
								API.dbg("pas 6");
								var indexChoice = 0;
								//save the items (choice and components) that must be  sold
								for(var i=1; i<allProducts.length();i++) //just choice products  the main product was sold above
								{
									if(allProducts[i].productCode != productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component and not an open choice
									{	
										var otherProdChoice = new Object();
										otherProdChoice.grillInstructionsArray = new Array();
										if(allProducts[i].productCode.level !=0)
										{
											otherProdChoice.qty = allProducts[i].quantity*qty;
										}
										else
										{
											otherProdChoice.qty = allProducts[i].quantity;
										}	
										
										//get the grill lines if any
										for(var line = i+1; line<allProducts.length(); line++)
										{
											var translate_tab = Number(getGrillIndex(translate_valueMealCode, allProducts[i].productCode, translate_ocupiedIndexes));
											if(allProducts[line].isGrillLine == "true")
											{
												var stop = allProducts[i].quantity *qty;
												if(Number(targetQtyDivideBy) != 2)
												{
													stop =allProducts[i].quantity;
												}
												for(var x = 0; x < stop; x++)  //if we have two choice with the same qrill instruction
												{
													var grillObject = new Object();
													var t_grillLength = otherProdChoice.grillInstructionsArray.length;
													grillObject.productCode = allProducts[line].productCode;
													grillObject.grilledQuantity = allProducts[line].grilledQuantity;
													grillObject.specialModifiers = allProducts[line].specialModifiers;
													grillObject.translate_grillTabIndexProd = Number(translate_tab) +Number(x);
													translate_ocupiedIndexes += grillObject.translate_grillTabIndexProd+"|";	
													grillObject.grillTabIndexProd=""; //not seted  this is used just for sale transformed products
													otherProdChoice.grillInstructionsArray[t_grillLength] = grillObject;
												}
											}
											else
											{
												break;
											}
										}
										
										otherProdChoice.prodCode =  allProducts[i].productCode;
										otherProd.choiceArray[indexChoice] = otherProdChoice;
										indexChoice++;
										/*
										storeProducts[storeProducts_Counter] = otherProd;
										storeProducts_Counter++;
										*/
									}
								}
								API.dbg("pas 7");
								//we may have some choice that were not added because the first step was in else
								for(var i=0; i<storeProducts1_Counter;i++)
								{
									//set the grilltab index
									var tabIndex = getGrillIndex(translate_valueMealCode, storeProducts1[i].prodCode, translate_ocupiedIndexes);
									for(var x=0 ; x < storeProducts1[i].grillInstructionsArray.length(); x++)
									{
										storeProducts1[i].grillInstructionsArray[x].translate_grillTabIndexProd = tabIndex; 
										translate_ocupiedIndexes += storeProducts1[i].grillInstructionsArray[x].translate_grillTabIndexProd.translate_grillTabIndexProd+"|";
										storeProducts1[i].grillInstructionsArray[x].grillTabIndexProd="";
									}									
									otherProd.choiceArray[indexChoice] = storeProducts1[i];
									indexChoice++;
								}
								
								API.dbg("pass 8");
								
								indexChoice=0;
								
								//in case there are any promo left  we must add the choice also 
								for(var i=1; i<allProducts.length();i++) //just choice products  the main product was sold above
								{
									if(allProducts[i].productCode != productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
									{	
										//save the components also for the remining non transformed product
										if(productsLevelZero[u].quantityPromo != 0)  //add also the remianing qty this is necessary because we void the item below
										{
											var otherOpenProdChoice = new Object();
											otherOpenProdChoice.grillInstructionsArray = new Array();
											if(allProducts[i].productCode.level !=0)
											{
												otherOpenProdChoice.qtyPromo = allProducts[i].quantity*productsLevelZero[u].quantityPromo;  //componentQTY is the current used QTY is not having always value 2
											}
											else
											{
												otherOpenProdChoice.qtyPromo = allProducts[i].quantity;
											}	

											//get the grill lines if any
											var tab = Number(getGrillIndex(valueMealCode, allProducts[i].productCode, ocupiedIndexes));
											for(var line = i+1; line<allProducts.length(); line++)
											{
												if(allProducts[line].isGrillLine == "true")
												{
													for(var x = 0; x < allProducts[i].quantity; x++)  //if we have two choice with the same qrill instruction
													{
														var grillObject = new Object();
														var grillLength = otherOpenProdChoice.grillInstructionsArray.length;
														grillObject.productCode = allProducts[line].productCode;
														grillObject.grilledQuantity = allProducts[line].grilledQuantity;
														grillObject.specialModifiers = allProducts[line].specialModifiers;
														//to do get the grill tab index
														grillObject.grillTabIndexProd = Number(tab)+Number(x);
														ocupiedIndexes += grillObject.grillTabIndexProd+"|";
														grillObject.translate_grillTabIndexProd="";
														otherOpenProdChoice.grillInstructionsArray[grillLength] = grillObject;
													}
												}
												else
												{
													break;
												}
											}
											//to do check in transaltion table maybe we need to sale something else
											otherOpenProdChoice.prodCode =  allProducts[i].productCode;
											//otherProdChoice.prodCode =  allProducts[i].productCode;
											objProd.choiceArray[indexChoice] = otherProdChoice;
											indexChoice++;
											/*
											storeProducts2[storeProducts2_Counter] = otherOpenProd;
											storeProducts2_Counter++;
											*/
										}
									}
								}
								API.dbg("pas 9");
								//we finish the transformation we reset the grillIndexes
								ocupiedIndexes="";
								translate_ocupiedIndexes="";
							
							}
							else //we cannot make the transalation 
							{   //we save the current index
							API.dbg("pas 10");
								var objProd = new Object();
								objProd.grillInstructionsArray = new Array();
								objProd.choiceArray = new Array();
								objProd.lineView = u;
								objProd.prodCode = productCode;
								objProd.remainingQTY=0;
								objProd.promoQTY = productsLevelZero[u].quantityPromo; 
								indexes[index_Counter] = objProd; //the line in the sale view
								index_Counter++;
								
								//get the grill lines if any for the main product
								
								//we need to add this grill instruction also for the new product
								translatedGrillIndex_Counter =0;
								
								for(var line = 1; line<allProducts.length(); line++)
								{
									if(allProducts[line].isGrillLine == "true")
									{
										var grillObject = new Object();
										grillObject.productCode = allProducts[line].productCode;
										grillObject.grilledQuantity = allProducts[line].grilledQuantity;
										grillObject.parrentCode = allProducts[i].productCode;
										//if si having direct instruction then is not a value meal 
										grillObject.grillTabIndexProd = 0;
										grillObject.translate_grillTabIndexProd=translated_grillIndex;
										translate_ocupiedIndexes +=translated_grillIndex+"|";;
										grillObject.specialModifiers = allProducts[line].specialModifiers;
										objProd.grillInstructionsArray[line-1] = grillObject;
										
										translatedGrillArray[translatedGrillIndex_Counter] = grillObject;
										translatedGrillIndex_Counter++;
									}
									else
									{
										break;
									}
								}
							API.dbg("pas 11");	
							var grillLength = objProd.grillInstructionsArray.length;
								//if the product is a value meal then we may have some grill instruction of its components
								for(var line = 1; line<allProducts.length(); line++)
								{
									if(allProducts[line].level != "0" && allProducts[line].prodAction =="0" && allProducts[line].isGrillLine == "false") //it's a component
									{
										//get all gril instructions
										var tab = Number(getGrillIndex(valueMealCode, allProducts[line].productCode, ocupiedIndexes));
										for(var grillLine = line+1; grillLine < allProducts.length(); grillLine++)
										{
											if(allProducts[grillLine].isGrillLine == "true")
											{
												for(var x = 0; x < allProducts[line].quantity; x++)  //if we have two components with the same qrill instruction
												{
													var grillObject = new Object();
													grillObject.productCode = allProducts[grillLine].productCode;
													grillObject.grilledQuantity = allProducts[grillLine].grilledQuantity;
													grillObject.specialModifiers = allProducts[grillLine].specialModifiers;
													objProd.grillInstructionsArray[grillLength+grillLine-line-1] = grillObject;
													grillObject.parrentCode = allProducts[line].productCode;
													grillObject.second = x;
													//get the grill tab index
													grillObject.grillTabIndexProd = Number(tab)+Number(x);
													ocupiedIndexes += grillObject.grillTabIndexProd+"|";
														
													grillObject.translate_grillTabIndexProd="-1";
													translatedGrillArray[translatedGrillIndex_Counter] = grillObject;
													translatedGrillIndex_Counter++;
												}
											}
											else
											{
												break;
											}
										}
										
									}
								}
								API.dbg("pas 12");
								var indexChoice=0;
								//save the items (choice and components) that must be  sold
								for(var i=1; i<allProducts.length();i++) //just choice products  the main product was sold above
								{
									//these products are choice and must be added when the transformation is possible
									if(allProducts[i].productCode != productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
									{	
										var otherProdChoice = new Object();
										otherProdChoice.grillInstructionsArray = new Array();
										
										if(allProducts[i].productCode.level !=0)
										{
											otherProdChoice.qty = allProducts[i].quantity*qtyCurrent;
										}
										else
										{
											otherProdChoice.qty = allProducts[i].quantity;
										}
										
										//get the grill lines if any
										for(var line = i+1; line<allProducts.length(); line++)
										{
											if(allProducts[line].isGrillLine == "true")
											{
												for(var x = 0; x < allProducts[i].quantity; x++)  //if we have two choices with the same qrill instruction
												{
													var grillObject = new Object();
													grillObject.productCode = allProducts[line].productCode;
													grillObject.second = x;
													grillObject.grilledQuantity = allProducts[line].grilledQuantity;
													grillObject.specialModifiers = allProducts[line].specialModifiers;
													grillObject.translate_grillTabIndexProd="-1";
													otherProdChoice.grillInstructionsArray[line-i-1+x] = grillObject;
												}
											}
											else
											{
												break;
											}
										}
										
										otherProdChoice.prodCode =  allProducts[i].productCode;
										storeProducts1[storeProducts_Counter] = otherProdChoice;
										storeProducts1_Counter++;
										
									}
								}
								API.dbg("pas 13");
								//in case there are any promo left  we must add the choice also 
								for(var i=1; i<allProducts.length();i++) //just choice products  the main product was sold above
								{
									if(allProducts[i].productCode != productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
									{										
										//save the components also for the remining non transformed product
										if(productsLevelZero[u].quantityPromo != 0)  //add also the remianing qty this is necessary because we void the item below
										{
											var otherOpenProdChoice = new Object();
											otherOpenProdChoice.grillInstructionsArray = new Array();
											if(allProducts[i].productCode.level !=0)
											{
												otherOpenProdChoice.qty = allProducts[i].quantity*productsLevelZero[u].quantityPromo;  //componentQTY is the current used QTY is not having always value 2
											}
											else
											{
												otherOpenProdChoice.qty = allProducts[i].quantity;
											}	
											
											//get the grill lines if any
											var tab = Number(getGrillIndex(valueMealCode, allProducts[i].productCode, ocupiedIndexes));
											for(var line = i+1; line<allProducts.length(); line++)
											{
												if(allProducts[line].isGrillLine == "true")
												{
													for(var x = 0; x < allProducts[i].quantity; x++)  //if we have two choices with the same qrill instruction
													{
														var grillObject = new Object();
														grillObject.productCode = allProducts[line].productCode;
														grillObject.grilledQuantity = allProducts[line].grilledQuantity;
														grillObject.specialModifiers = allProducts[line].specialModifiers;
														grillObject.grillTabIndexProd = Number(tab)+Number(x);
														ocupiedIndexes += grillObject.grillTabIndexProd+"|";
														otherOpenProdChoice.grillInstructionsArray[line-i-1+x] = grillObject;
													}
												}
												else
												{
													break;
												}
											}
											
											//to do check in transaltion table maybe we need to sale something else
											otherOpenProdChoice.prodCode =  allProducts[i].productCode;
											objProd.choiceArray[indexChoice] = otherOpenProdChoice;
											indexChoice++;
											/*
											storeProducts2[storeProducts2_Counter] = otherOpenProd;
											storeProducts2_Counter++;
											*/
										}
									}
								}
								API.dbg("pas 14");
							}
					   }
					   else //componentQTY <= qtyCurrent  the componentQTY is the remaining necessary qty 
					   {
					   API.dbg("pas 15");
							found = true;
							var saleQTY;
							if(Number(targetQtyDivideBy) != 1)
							{
								saleQTY = new BigDecimal(familyVoucherArr[selectedOption].componentArr[j].qty);
							}
							else
							{
								saleQTY = new BigDecimal(componentQTY);
							}
							saleQTY = saleQTY.divide(targetQtyDivideBy,6);

							var otherProd = new Object();
							otherProd.grillInstructionsArray = new Array();
							otherProd.choiceArray = new Array();
							otherProd.qty=Number(saleQTY);
							var qty = saleQTY;
							
							otherProd.prodCode =  familyVoucherArr[selectedOption].componentArr[j].codes[t].translate;
							storeProducts[storeProducts_Counter] = otherProd;
							storeProducts_Counter++;
							//PosDoSaleJS(familyVoucherArr[selectedOption].componentArr[j].codes[t].translate);
							//PosDoQuantum(-1);
							
							var objProd = new Object();
							objProd.grillInstructionsArray = new Array();
							objProd.choiceArray = new Array();
							objProd.lineView = u;
							objProd.prodCode = productCode;
							objProd.remainingQTY= qtyCurrent - componentQTY;
							objProd.promoQTY = productsLevelZero[u].quantityPromo; 
							indexes[index_Counter] = objProd; //the line in the sale view
							index_Counter++;
							
							//for the translated product we may have some additional grill instruction and grill component instruction
							grillLength = otherProd.grillInstructionsArray.length;
							for(var i=0; i<translatedGrillIndex_Counter; i++)
							{
								var parrentCode= translatedGrillArray[i].parrentCode;
								if(i>=1)
								{
									if(translatedGrillArray[i].parrentCode == translatedGrillArray[i-1].parrentCode && translatedGrillArray[i].second == translatedGrillArray[i-1].second )  //grill instruction for the same component or choice  .second referst to the second component or second identical choice
									{
										translatedGrillArray[i].translate_grillTabIndexProd = translatedGrillArray[i-1].translate_grillTabIndexProd;
									}
								}
								if(translatedGrillArray[i].translate_grillTabIndexProd =="-1")
								{
									translatedGrillArray[i].translate_grillTabIndexProd = getGrillIndex(translate_valueMealCode, parrentCode, translate_ocupiedIndexes);
									translate_ocupiedIndexes += translatedGrillArray[i].translate_grillTabIndexProd+"|";
								}
								
								API.dbg("translate_ocupiedIndexes "+ translate_ocupiedIndexes)
								otherProd.grillInstructionsArray[grillLength+i] = translatedGrillArray[i]; 
							
							}		
							
							API.dbg("pas 16 " +otherProd.grillInstructionsArray.length+ " " + translatedGrillIndex_Counter);
							grillLength = otherProd.grillInstructionsArray.length;
							//get the grill lines if any for the main product
							for(var line = 1; line<allProducts.length(); line++)
							{
								
								if(allProducts[line].isGrillLine == "true")
								{
									var stop = componentQTY;
									if(Number(targetQtyDivideBy) != 2)
									{
										stop =1;
									}
									for(var x = 0; x < stop; x++)  //if we have two components with the same qrill instruction
									{
										var grillObject = new Object();
										var translate_grillLength = otherProd.grillInstructionsArray.length;
										grillObject.productCode = allProducts[line].productCode;
										grillObject.grilledQuantity = allProducts[line].grilledQuantity;
										grillObject.specialModifiers = allProducts[line].specialModifiers;
										otherProd.grillInstructionsArray[translate_grillLength] = grillObject;
										//if si having direct instruction then is not a value meal 
										grillObject.grillTabIndexProd = 0;
										grillObject.translate_grillTabIndexProd =  Number(translated_grillIndex)+Number(x);
										translate_ocupiedIndexes +=grillObject.translate_grillTabIndexProd+"|";
									}
									
									//for the source product
									var grillObject = new Object();
									var grillLength = objProd.grillInstructionsArray.length;
									grillObject.productCode = allProducts[line].productCode;
									grillObject.grilledQuantity = allProducts[line].grilledQuantity;
									grillObject.specialModifiers = allProducts[line].specialModifiers;
									objProd.grillInstructionsArray[grillLength] = grillObject;
									//if si having direct instruction then is not a value meal 
									grillObject.grillTabIndexProd = 0;
								}
								else
								{
									break;
								}
							}
							//API.dbg("pas 17b "+objProd.grillInstructionsArray);
							API.dbg("pas 17 "+ otherProd.grillInstructionsArray.length);
							var t_grillLength = otherProd.grillInstructionsArray.length;
							var grillLength =objProd.grillInstructionsArray.length;
							//if the product is a value meal then we may have some grill instruction of its components
							for(var line = 1; line<allProducts.length(); line++)
							{
								if(allProducts[line].level != "0" && allProducts[line].prodAction =="0" && allProducts[line].isGrillLine =="false") //it's a component
								{
									//get all gril instructions
									var tab = Number(getGrillIndex(valueMealCode, allProducts[line].productCode, ocupiedIndexes));
									var tab_translate = Number(getGrillIndex(translate_valueMealCode, allProducts[line].productCode, translate_ocupiedIndexes));
									for(var grillLine = line+1; grillLine < allProducts.length(); grillLine++)
									{
										if(allProducts[grillLine].isGrillLine == "true")
										{
											//API.DbgMessageBox("enter "+ allProducts[line].quantity);
											var stop = allProducts[line].quantity * componentQTY;
											if(Number(targetQtyDivideBy) != 2)
											{
												stop =allProducts[line].quantity;
											}
											for(var x = 0; x < stop; x++)  //if we have two components with the same qrill instruction
											{
												t_grillLength = otherProd.grillInstructionsArray.length;
												var grillObject = new Object();
												grillObject.productCode = allProducts[grillLine].productCode;
												grillObject.grilledQuantity = allProducts[grillLine].grilledQuantity;
												grillObject.specialModifiers = allProducts[grillLine].specialModifiers;
													
												grillObject.translate_grillTabIndexProd = Number(tab_translate)+Number(x);
												translate_ocupiedIndexes += grillObject.translate_grillTabIndexProd+"|";
												otherProd.grillInstructionsArray[t_grillLength] = grillObject;
											}
											for(var x = 0; x < allProducts[line].quantity; x++)  //if we have two components with the same qrill instruction
											{
												grillLength =objProd.grillInstructionsArray.length;
												var grillObject = new Object();
												grillObject.productCode = allProducts[grillLine].productCode;
												grillObject.grilledQuantity = allProducts[grillLine].grilledQuantity;
												grillObject.specialModifiers = allProducts[grillLine].specialModifiers;
												grillObject.grillTabIndexProd = Number(tab)+Number(x);
												ocupiedIndexes += grillObject.grillTabIndexProd+"|";
												objProd.grillInstructionsArray[grillLength] = grillObject;
											}
										}
										else
										{
											break;
										}
									}
									
								}
							}
							API.dbg("pas 18 "+objProd.grillInstructionsArray.length);
							
							var indexChoice = 0;	
							var indexChoice1 = 0;							
							//save the items (choice and components) that must be  sold
							for(var i=1; i<allProducts.length();i++) //just choice products  the main product was sold above
						    {
								if(allProducts[i].productCode != productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
								{	
									var otherProdChoice = new Object();
									otherProdChoice.grillInstructionsArray = new Array();
									
									if(allProducts[i].productCode.level !=0)
									{
										otherProdChoice.qty = allProducts[i].quantity*componentQTY;  //componentQTY is the current used QTY is not having always value 2
										
									}
									else
									{
										otherProdChoice.qty = allProducts[i].quantity;
									}
									
									//get the grill lines if any
									var translate_tab = Number(getGrillIndex(translate_valueMealCode, allProducts[i].productCode, translate_ocupiedIndexes));
									for(var line = i+1; line<allProducts.length(); line++)
									{
										if(allProducts[line].isGrillLine == "true")
										{
											//API.DbgMessageBox("enter "+ allProducts[i].quantity);
											var stop = allProducts[i].quantity*componentQTY;
											if(Number(targetQtyDivideBy) != 2)
											{
												stop =allProducts[i].quantity;
											}
											for(var x = 0; x < stop; x++)  //if we have two choices with the same qrill instruction
											{
												var grillObject = new Object();
												var translate_grillLength = otherProdChoice.grillInstructionsArray.length;
												grillObject.productCode = allProducts[line].productCode;
												grillObject.grilledQuantity = allProducts[line].grilledQuantity;
												grillObject.specialModifiers = allProducts[line].specialModifiers;
												otherProdChoice.grillInstructionsArray[translate_grillLength] = grillObject;
												//to do get the grill tab index
												grillObject.translate_grillTabIndexProd = Number(translate_tab)+Number(x);
												translate_ocupiedIndexes += grillObject.translate_grillTabIndexProd+"|";
											}
										}
										else
										{
											break;
										}
									}
									
									otherProdChoice.prodCode =  allProducts[i].productCode;
									otherProd.choiceArray[indexChoice] = otherProdChoice;
									indexChoice++;
									/*
									storeProducts[storeProducts_Counter] = otherProd;
									storeProducts_Counter++;
									*/
									
									//save the components also for the remining non transformed product
									if(objProd.remainingQTY !=0 || objProd.promoQTY != 0)  //add also the remianing qty this is necessary because we void the item below
									{
										var otherOpenProdChoice = new Object();
										otherOpenProdChoice.grillInstructionsArray = new Array();
										
										if(allProducts[i].productCode.level !=0)
										{
											otherOpenProdChoice.qty = allProducts[i].quantity*Number(objProd.remainingQTY);  //componentQTY is the current used QTY is not having always value 2
											otherOpenProdChoice.qtyPromo = allProducts[i].quantity*objProd.promoQTY; 
										}
										else
										{
											otherOpenProdChoice.qty = allProducts[i].quantity;
										}	
										
										//get the grill lines if any
										var tab = Number(getGrillIndex(valueMealCode, allProducts[i].productCode, ocupiedIndexes));
										for(var line = i+1; line<allProducts.length(); line++)
										{
											if(allProducts[line].isGrillLine == "true")
											{
												for(var x = 0; x < allProducts[i].quantity; x++)  //if we have two components with the same qrill instruction
												{
													var grillObject = new Object();
													var grillLength = otherOpenProdChoice.grillInstructionsArray.length;
													grillObject.productCode = allProducts[line].productCode;
													grillObject.grilledQuantity = allProducts[line].grilledQuantity;
													grillObject.specialModifiers = allProducts[line].specialModifiers;
													otherOpenProdChoice.grillInstructionsArray[grillLength] = grillObject;
													grillObject.grillTabIndexProd = Number(tab)+Number(x);
													ocupiedIndexes += grillObject.grillTabIndexProd+"|";
												}
											}
											else
											{
												break;
											}
										}
										//to do check in transaltion table maybe we need to sale something else
										otherOpenProdChoice.prodCode =  allProducts[i].productCode;
										objProd.choiceArray[indexChoice1] = otherOpenProdChoice;
										indexChoice1++;
										/*
										storeProducts2[storeProducts2_Counter] = otherOpenProd;
										storeProducts2_Counter++;
										*/
									}
									
								}	
						    }	
							API.dbg("pas 18bis");
							//we may have some choice that were not added because the first step was in else
							for(var i=0; i<storeProducts1_Counter;i++)
							{
								//set the grilltab index
								var tabIndex =  getGrillIndex(translate_valueMealCode, storeProducts1[i].prodCode, translate_ocupiedIndexes);
								for(var x=0 ; x < storeProducts1[i].grillInstructionsArray.length; x++)
								{
									storeProducts1[i].grillInstructionsArray[x].translate_grillTabIndexProd = tabIndex;
									translate_ocupiedIndexes += grillObject.translate_grillTabIndexProd+"|";
								}
								otherProd.choiceArray[indexChoice] = storeProducts1[i];
								indexChoice++;
							}
							API.dbg("pas 19");
							//we finish the transformation we reset the grillIndexes
							ocupiedIndexes="";
							translate_ocupiedIndexes="";	
					   } 
					   componentQTY = componentQTY - qtyCurrent;
					   if(componentQTY < 0 )
					   {
							found = true;  //need to break from the external for
					   }
					   break; //found it no need to keep searching	
					}
				}
				if(found  == true)  //the translation product was added
				{
					API.dbg("pas 20");
					//first we need to sort them by the line number
					for(var k = 0; k< index_Counter; k++)  //from last to first to ensure that lines will be valid
					{
						for( x = k+1; x< index_Counter; x++)
						{
							if(Number(indexes[k].lineView) > Number(indexes[x].lineView))
							{
								var temp = indexes[k];
								indexes[k] = indexes[x];
								indexes[x] = temp;
							}			
						}
					}
					API.dbg("pas 21");
					//first select the last line of the produt that will be removed
					PosDoSelIndex(indexes[index_Counter-1].lineView+"");
					
					//sale new products
					for(var k = 0; k < storeProducts_Counter; k++)  
					{   //this will sale vm and components
						//PosDoQuantum(storeProducts[k].qty);
						for(var xt = 0 ;xt < storeProducts[k].qty; xt++)
						{
							PosDoSaleJS(storeProducts[k].prodCode);	
											
							//sale the choice if any
							for(var x=0; x < storeProducts[k].choiceArray.length; x++)
							{
								for(var y = 0; y< (storeProducts[k].choiceArray[x].qty /storeProducts[k].qty) ; y++)
								{
									PosDoSaleJS(storeProducts[k].choiceArray[x].prodCode);	
								}
							}
							API.dbg("pas 22");
							//API.DbgMessageBox("length "+storeProducts[k].grillInstructionsArray.length);
							//add grill
							//because of adding choice we already have the needed line selected we just need to add the grill instructions 
							var prodHasGrill =false;
							if(storeProducts[k].grillInstructionsArray.length !=0)
							{
								prodHasGrill =true;
								PosDoGrillStart("199");
								
							}
							else
							{
								if(storeProducts[k].choiceArray.length!=0)
								{
									for(var z =0; z< storeProducts[k].choiceArray.length; z++)
									{							
										if(storeProducts[k].choiceArray[z].grillInstructionsArray.length !=0) //at least one choice have grill instruction
										{
											prodHasGrill =true;
											PosDoGrillStart("199");
											break;
										}
									}
								}
							}
							for(var y=0; y < storeProducts[k].grillInstructionsArray.length; y++)
							{
								//API.DbgMessageBox("component");
								//API.dbg("enter if grill " + storeProducts[k].grillInstructionsArray[y].translate_grillTabIndexProd);
								//API.DbgMessageBox(storeProducts[k].grillInstructionsArray[y].translate_grillTabIndexProd+" "+ storeProducts[k].grillInstructionsArray[y].productCode);
								PosDoSelGrillIndex(storeProducts[k].grillInstructionsArray[y].translate_grillTabIndexProd.toString());

								if(storeProducts[k].grillInstructionsArray[y].specialModifiers !="0")
								{
									//API.dbg("posdogrilloper multi "+ storeProducts[k].grillInstructionsArray[y].productCode + " " +storeProducts[k].grillInstructionsArray[y].specialModifiers+"");
									PosDoGrillOperMulti("c", storeProducts[k].grillInstructionsArray[y].productCode.toString());
									PosDoGrillOperMulti("0", storeProducts[k].grillInstructionsArray[y].productCode.toString(),storeProducts[k].grillInstructionsArray[y].specialModifiers.toString());
								}
								else
								{
									if(storeProducts[k].grillInstructionsArray[y].grilledQuantity =="-1")
									{
										//PosDoGrillOperMulti("c", storeProducts[k].grillInstructionsArray[y].productCode);
										PosDoGrillOperMulti("c", storeProducts[k].grillInstructionsArray[y].productCode.toString());
										PosDoGrillOperMulti("m", storeProducts[k].grillInstructionsArray[y].productCode.toString());
									}
									else
									{
										//PosDoGrillOperMulti("c", storeProducts[k].grillInstructionsArray[y].productCode);
										PosDoGrillOperMulti("c", storeProducts[k].grillInstructionsArray[y].productCode.toString());
										PosDoGrillOperMulti("p", storeProducts[k].grillInstructionsArray[y].productCode.toString());
									}
								}
							}
							//PosDoGrillEnd("3");
							API.dbg("pas 23");
							//add the grill instruction for choices
							for(var z =0; z< storeProducts[k].choiceArray.length; z++)
							{
								for(var y=0; y < storeProducts[k].choiceArray[z].grillInstructionsArray.length; y++)
								{
									//API.DbgMessageBox("choice");
									
									//API.DbgMessageBox(storeProducts[k].choiceArray[z].grillInstructionsArray[y].translate_grillTabIndexProd + " " +storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode)
									PosDoSelGrillIndex(storeProducts[k].choiceArray[z].grillInstructionsArray[y].translate_grillTabIndexProd.toString());
									//PosDoGrillOperMulti("c", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode);
									if(storeProducts[k].choiceArray[z].grillInstructionsArray[y].specialModifiers !="0")
									{
										//API.DbgMessageBox("modifiers "+ storeProducts[k].choiceArray[z].grillInstructionsArray[y].specialModifiers);
										PosDoGrillOperMulti("c", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString());
										PosDoGrillOperMulti("0", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString(),storeProducts[k].choiceArray[z].grillInstructionsArray[y].specialModifiers.toString());
									}
									else
									{
										if(storeProducts[k].choiceArray[z].grillInstructionsArray[y].grilledQuantity =="-1")
										{
											PosDoGrillOperMulti("c", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString());
											PosDoGrillOperMulti("m", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString());
										}
										else
										{
											PosDoGrillOperMulti("c", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString());
											PosDoGrillOperMulti("p", storeProducts[k].choiceArray[z].grillInstructionsArray[y].productCode.toString());
										}
									}
								}
							}
							if(prodHasGrill ==true)
							{
								PosDoGrillEnd("3");
							}
							API.dbg("pas 24");
						}
						//PosDoQuantum(-1);
					}
					/*
					for(var k = 0; k < storeProducts1_Counter ; k++)  //from last to first to ensure that lines will be valid
					{   //this will sale just components for the VM that enter the first else
						//PosDoQuantum(storeProducts1[k].qty);
						for(var x = 0 ;x < storeProducts1[k].qty; x++)
						{
							PosDoSaleJS(storeProducts1[k].prodCode);
						}
						//PosDoQuantum(-1);
					}	
					*/
					API.dbg("pas 25");
					//remove all products that were replaced
					for(var k = index_Counter-1; k>=0 ; k--)  //from last to first to ensure that lines will be valid
					{  
						var line = indexes[k].lineView;
						if(indexes[k].remainingQTY ==0 && indexes[k].promoQTY == 0)
						{
							if(PosDoSelIndex(line+"") ==true) //ensure is a string
							{								
								PosDoVoidLine();
							}
							else
							{
								API.dbg("selected line was not successful "+ line);
								API.dbg(view);
							}
						}
						else  //just reduce qty
						{
							if(PosDoSelIndex(line+"") ==true) //ensure is a string
							{					
								if(indexes[k].promoQTY !=0) //we have promo
								{  //in this case first we need to anulate the promo
								    PosDoQuantum(0);
									PosDoPromoItem();
									PosDoQuantum(-1);								   
								}
								PosDoVoidLine();
								
								//if I use pos do quantum it will affect any other qty of the same product that have grill options 
								for(var x = 0 ;x < indexes[k].remainingQTY; x++)
								{
									PosDoSaleJS(indexes[k].prodCode);
									for(var y = 0 ;y < indexes[k].choiceArray.length; y++)
									{
										qty = indexes[k].choiceArray[y].qty;
										for(var z = 0 ;z < Number(qty/indexes[k].remainingQTY); z++)
										{
											PosDoSaleJS(indexes[k].choiceArray[y].prodCode);
										}
									}			
									//sale the choices
									for(var y = 0 ;y < indexes[k].choiceArray.length; y++)
									{
										qty = indexes[k].choiceArray[y].qty;
										for(var z = 0 ;z < Number(qty/indexes[k].remainingQTY); z++)
										{
											//PosDoSaleJS(indexes[k].choiceArray[y].prodCode);
											//add the grill instruction for the choice
											if(indexes[k].choiceArray[y].grillInstructionsArray.length != 0)
											{
												PosDoGrillStart("199");
											}
											for(var w =0; w < indexes[k].choiceArray[y].grillInstructionsArray.length; w++)
											{
												//PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode);
												PosDoSelGrillIndex(indexes[k].choiceArray[y].grillInstructionsArray[w].grillTabIndexProd.toString());
												if(indexes[k].choiceArray[y].grillInstructionsArray[w].specialModifiers !="0")
												{
													PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													PosDoGrillOperMulti("0", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString(),indexes[k].choiceArray[y].grillInstructionsArray[w].specialModifiers.toString());
												}
												else
												{
													if(indexes[k].grillInstructionsArray[y].grilledQuantity =="-1")
													{
														PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
														PosDoGrillOperMulti("m", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													}
													else
													{
														PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
														PosDoGrillOperMulti("p", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													}
												}
											}
											if(indexes[k].choiceArray[y].grillInstructionsArray.length != 0)
											{
												PosDoGrillEnd("3");
											}
										}
									}
									
									//add the grill for the main product or components
									//API.DbgMessageBox("add "+ indexes[k].grillInstructionsArray.length);
									if(indexes[k].grillInstructionsArray.length != 0)
									{
										PosDoGrillStart("199");
									}
									for(var w = 0 ;w < indexes[k].grillInstructionsArray.length; w++)
									{
										//PosDoGrillOperMulti("c", indexes[k].grillInstructionsArray[w].productCode);
										//API.DbgMessageBox(indexes[k].grillInstructionsArray[w].grillTabIndexProd.toString() + " code " + indexes[k].grillInstructionsArray[w].productCode.toString() + " mod " +indexes[k].grillInstructionsArray[w].specialModifiers.toString() + " qty "+ indexes[k].grillInstructionsArray[w].grilledQuantity.toString());
										PosDoSelGrillIndex(indexes[k].grillInstructionsArray[w].grillTabIndexProd.toString());
										if(indexes[k].grillInstructionsArray[w].specialModifiers.toString() !="0")
										{
											//PosDoGrillOperMulti("c", indexes[k].grillInstructionsArray[w].productCode.toString());
											PosDoGrillOperMulti("0", indexes[k].grillInstructionsArray[w].productCode.toString(),indexes[k].grillInstructionsArray[w].specialModifiers.toString());
										}
										else
										{
											if(indexes[k].grillInstructionsArray[w].grilledQuantity.toString() =="-1")
											{
												//PosDoGrillOperMulti("c", indexes[k].grillInstructionsArray[w].productCode.toString());
												PosDoGrillOperMulti("m", indexes[k].grillInstructionsArray[w].productCode.toString());
											}
											else
											{
												//PosDoGrillOperMulti("c", indexes[k].grillInstructionsArray[w].productCode.toString());
												PosDoGrillOperMulti("p", indexes[k].grillInstructionsArray[w].productCode.toString());
												
												API.dbg("enter else");
											}
										}
									}
									if(indexes[k].grillInstructionsArray.length != 0)
									{
										PosDoGrillEnd("3");
									}
								}
								for(var x = 0 ;x < indexes[k].promoQTY; x++)
								{
									PosDoSaleJS(indexes[k].prodCode);
									PosDoPromoItem();
									
									for(var y = 0 ;y < indexes[k].choiceArray.length; y++)
									{
										qty = indexes[k].choiceArray[y].qty;
										for(var z = 0 ;z < Number(qty/indexes[k].promoQTY); z++)
										{
											PosDoSaleJS(indexes[k].choiceArray[y].prodCode);
										}
									}
									//sale the choices
									for(var y = 0 ;y < indexes[k].choiceArray.length; y++)
									{
										qty = indexes[k].choiceArray[y].qtyPromo;
										for(var z = 0 ;z < Number(qty/indexes[k].promoQTY); z++)
										{
											//PosDoSaleJS(indexes[k].choiceArray[y].prodCode);
											//add the grill instruction for the choice
											if(indexes[k].choiceArray[y].grillInstructionsArray.length!= 0)
											{
												PosDoGrillStart("199");
											}
											for(var w =0; w < indexes[k].choiceArray[y].grillInstructionsArray.length; w++)
											{
												//PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode);
												PosDoSelGrillIndex(indexes[k].choiceArray[y].grillInstructionsArray[w].grillTabIndexProd.toString());
												if(indexes[k].choiceArray[y].grillInstructionsArray[w].specialModifiers !="0")
												{
													PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													PosDoGrillOperMulti("0", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString(),indexes[k].choiceArray[y].grillInstructionsArray[w].specialModifiers.toString());
												}
												else
												{
													if(indexes[k].grillInstructionsArray[y].grilledQuantity =="-1")
													{
														PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
														PosDoGrillOperMulti("m", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													}
													else
													{
														PosDoGrillOperMulti("c", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
														PosDoGrillOperMulti("p", indexes[k].choiceArray[y].grillInstructionsArray[w].productCode.toString());
													}
												}
											}
											if(indexes[k].choiceArray[y].grillInstructionsArray.length!= 0)
											{
												PosDoGrillEnd("3");
											}
										}
									}
									
									//add the grill for the main product or components
									//API.DbgMessageBox("add "+ indexes[k].grillInstructionsArray.length);
									if(indexes[k].grillInstructionsArray.length != 0)
									{
										PosDoGrillStart("199");
									}
									for(var w = 0 ;w < indexes[k].grillInstructionsArray.length; w++)
									{
										//PosDoGrillOperMulti("c", indexes[k].grillInstructionsArray[w].productCode);
										PosDoSelGrillIndex(indexes[k].grillInstructionsArray[w].grillTabIndexProd.toString());
										if(indexes[k].grillInstructionsArray[w].specialModifiers !="0")
										{
											PosDoGrillOperMulti("0", indexes[k].grillInstructionsArray[w].productCode.toString(),indexes[k].grillInstructionsArray[w].specialModifiers.toString());
										}
										else
										{
											if(indexes[k].grillInstructionsArray[w].grilledQuantity =="-1")
											{
												PosDoGrillOperMulti("m", indexes[k].grillInstructionsArray[w].productCode.toString());
											}
											else
											{
												PosDoGrillOperMulti("p", indexes[k].grillInstructionsArray[w].productCode.toString());
											}
										}
									}
									if(indexes[k].grillInstructionsArray.length != 0)
									{
										PosDoGrillEnd("3");
									}
								}
								
							}
							else
							{
								API.dbg("selected line was not successful "+ line);
								API.dbg(view);
							}
						}
					}
					API.dbg("pas 26");
					/*
					//sell open choic e if any for products that are not transformed
					for(var k = 0; k < storeProducts2_Counter; k++)  //from last to first to ensure that lines will be valid
					{   //this will sale just components for the VM that enter the first else
						//PosDoQuantum(storeProducts2[k].qty);
						//if I use pos do quantum it will affect any other qty of the same product that have grill options 
						for(var x = 0 ;x < storeProducts2[k].qty; x++)
						{
							PosDoSaleJS(storeProducts2[k].prodCode);
						}
					}	
					*/
					break; //exit this component
				}
			}
		}
	}
	
	//delete all voided lines. They can cause issues durring the transformation 
	delete_voidLines();
	PosSetSessionProperty("FamilyPack_Voucher","false");
	familyVoucher_AvailableVouchers();
}

/*
Author: Mihai Secareanu 
Date: 15.07.2010
Description: This function will be used for NL Family Voucher. It will void some items and sell voucher ( reduced) products that will replace the voided items
*/
function familyVoucher_reverseTransformation()
{
	if(familyPack_ProductsArr.length == 0) //the configuration file was not found ot the array was not laoded
	{
		API.dbg("FamilyVoucher: the configuration file was not found ot the array was not loaded");
		return true; 
	}
	//delete all voided lines. They can cause issues durring the transformation 
	delete_voidLines();
	
	PosSetSessionProperty("FamilyPack_Voucher","true");
	var hlp = new BusinessObjectHelper;
	currView = hlp.getCurrentView();

	view= new XML(currView);
	API.dbg("family pack transform "+view);
	
	var productsLevelZero = view.ItemView.(level=="0" && quantity!="0");
	var itemLength = productsLevelZero.length();
	var doTransformation = false;
	var haveGrill =false;
	for(var k = itemLength-1; k >=0; k--)
	{
		productItemCode = productsLevelZero[k].itemCode;
		if( Number(productsLevelZero[k].quantity) -  Number(productsLevelZero[k].quantityPromo) > 0)
		{
			var qty = Number(productsLevelZero[k].quantity) -  Number(productsLevelZero[k].quantityPromo);
			var newCode = isVoucher(productsLevelZero[k].productCode);
			if( newCode != "-1")
			{
				
				
				newCodeArr = newCode.split("|"); //the format is prodCode|qty
				if((qty * Number(newCodeArr[1])) > 0 ) //doTransformtion is set to true just if at least one transformation occured
				{
					doTransformation = true;
				}
				//sell the product
				for(var i=0; i< qty * Number(newCodeArr[1]);i++)
				{
					PosDoSaleJS(newCodeArr[0]);
				}
				
				//sell all the choices
				var allProducts = view.ItemView.(itemCode == productItemCode);
				
				//test if there are some grill instruction to know if the warning must be displayed
				if(haveGrill ==false)
				{
					for(var line =0; line<allProducts.length();line++)
					{
						if(allProducts[line].isGrillLine=="true")
						{
							haveGrill =true;
							break;
						}
					
					}
				}
				
				for(var i=1; i<allProducts.length();i++) //just choice products  the mail product was sold above
				{
					if(allProducts[i].productCode != productsLevelZero[k].productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
					{	
						var qtySold =0;
						if(allProducts[i].productCode.level !=0)
						{
							qtySold = allProducts[i].quantity*qty;
						}
						else
						{
							qtySold = allProducts[i].quantity;
						}	
						for(var j=0; j< qtySold;j++)
						{
							PosDoSaleJS(allProducts[i].productCode);
						}
					}
				}
				
				//void product
				if(PosDoSelIndex(k+"") ==true) //ensure is a string
				{		
					if(Number(productsLevelZero[k].quantityPromo) !=0)  //we have promo items 
					{  //first remove the promo 
						PosDoQuantum(0);
						PosDoPromoItem();
						PosDoQuantum(-1);	
					}					
					PosDoVoidLine();
					//add again the promo items
					for(var x = 0 ;x < Number(productsLevelZero[k].quantityPromo); x++)
					{
						PosDoSaleJS(productsLevelZero[k].productCode);
						PosDoPromoItem();
					}
					//sell the required choices if any
					if(Number(productsLevelZero[k].quantityPromo) !=0)
					{
						for(var i=1; i<allProducts.length();i++) //just choice products  the mail product was sold above
						{
							if(allProducts[i].productCode != productsLevelZero[k].productCode && allProducts[i].isGrillLine == "false" && Number(allProducts[i].prodAction) !=0 && Number(allProducts[i].productType)!=4 && Number(allProducts[i].productType)!=5) //not grill line and not component
							{	
								var qtySold =0;
								if(allProducts[i].productCode.level !=0)
								{
									qtySold = allProducts[i].quantity*productsLevelZero[k].quantityPromo;
								}
								else
								{
									qtySold = allProducts[i].quantity;
								}	
								for(var j=0; j< qtySold;j++)
								{
									PosDoSaleJS(allProducts[i].productCode);
								}
							}
						}
					}
					API.dbg("after void  "+ k);
				}
				else
				{
					API.dbg("selected line was not successful "+ k);
					API.dbg(view);
				}
			}
		}
	}
	
	//delete all voided lines. They can cause issues durring the transformation 
	delete_voidLines();
	PosSetSessionProperty("FamilyPack_Voucher","false");
	if(doTransformation == true && haveGrill==true)
	{
		PosShowMessage(API.getLocalMsg("MSG_FamilyPackVoucher_Warning"));
	}
	return true; 
	
	function isVoucher(productCode)
	{
		var newCode="";
		var prodLength = familyPack_ProductsArr.length;
		var voucherLength = familyVoucherArr.length;
		for(var i=0; i < prodLength ;i++)   //search in all transaltion products
		{
			if(familyPack_ProductsArr[i].translation  == productCode)
			{
				newCode =familyPack_ProductsArr[i].code;
				//get the quantity
				for(var j=0; j < voucherLength; j++)
				{
					if(familyVoucherArr[j].name == familyPack_ProductsArr[i].voucher && familyPack_ProductsArr[i].voucher +"" !="")
					{
						//search the product in components
						var componentLength = familyVoucherArr[j].componentArr.length;
						for(var x=0; x < componentLength; x++)
						{
							var codeLength = familyVoucherArr[j].componentArr[x].codes.length;
							for(var t=0; t < codeLength; t++)
							{
								if(familyVoucherArr[j].componentArr[x].codes[t].code == familyPack_ProductsArr[i].code)
								{		
									newCode +="|"+ familyVoucherArr[j].componentArr[x].targetQtyDivideBy;
									return newCode;
								}			
							}
						}	
					}
					else if(familyPack_ProductsArr[i].voucher +"" =="")  //no name so the product is defined just in one voucher or has the same qty in all vouchers
					{
						var componentLength = familyVoucherArr[j].componentArr.length;
						for(var x=0; x < componentLength; x++)
						{
							var codeLength = familyVoucherArr[j].componentArr[x].codes.length;
							for(var t=0; t < codeLength; t++)
							{
								if(familyVoucherArr[j].componentArr[x].codes[t].code == familyPack_ProductsArr[i].code)
								{
									newCode +="|"+ familyVoucherArr[j].componentArr[x].targetQtyDivideBy;
									return newCode;
								}			
							}
						}	
					}
				}	
			}
		}
		return "-1";
	}
	
}




/**PosCheckPrinterStatusJS
 *
 * @brief - Checks the printer status, status sample: out of paper, paper jammed, paper near end and etc. 
 *          This function has been designed to block the NewPOS application process if any problem 
 *          is detected in the printer.
 *	     The bScriptCall is used to determine if the function is called from an workflow or from the scripts.
 *          If called from the scripts the method will return the status and not only true.
 * @return - always TRUE.
 * @since - PLE-446 - Generic implementation to detect the printer status.
 */
function PosCheckPrinterStatusJS(bScriptCall, endofDayReportCheck) 
{
	const BIT_0=1;
	const BIT_1=2;
	const BIT_2=4;
	const BIT_3=8;
	const BIT_4=16;
	const BIT_5=32;
	const BIT_6=64;
	const BIT_7=128;
	
	const STATUS_OK=0;
	const STATUS_NOT_AVAILABLE=1;
	const STATUS_PAPER_NEAR_END=0x02000000;
	const STATUS_PAPER_OUT=0x00000010;
	const STATUS_DOOR_OPEN=4;
	const STATUS_PAPER_JAM=5;
	const STATUS_USER_INTERVENTION=6;
	const STATUS_ERROR_UNKNOWN=7;
	const STATUS_API_UNAVAILABLE=8;
	
	const CLASS_PRINTER_STATUS=String.fromCharCode(0x01);
	const CLASS_BUSY_STATUS=String.fromCharCode(0x02);
	const CLASS_ERROR_STATUS=String.fromCharCode(0x03);
	const CLASS_PAPER_SENSOR_STATUS=String.fromCharCode(0x04);

	var returnValue = 0;
	try 
	{
		API.dbg("INFO : Checking default printer status.");
		while (true) 
		{
			// Sends the real-time status transmission command.
			var rc1=0;	// printer status
			var rc2=0;	// paper sensor status
			var rc3=0;	// busy status
			var rc4=0;	// error status
			
			rc1 = sndRcvPrnCmd(CLASS_PRINTER_STATUS);			
			if ((rc1!=STATUS_API_UNAVAILABLE) && (rc1!=STATUS_NOT_AVAILABLE)) 
			{
				rc2 = sndRcvPrnCmd(CLASS_PAPER_SENSOR_STATUS);
				rc3 = sndRcvPrnCmd(CLASS_BUSY_STATUS);
				rc4 = sndRcvPrnCmd(CLASS_ERROR_STATUS);
			}			
			if ((rc1+rc2+rc3+rc4)!=STATUS_OK) 
			{
				var msg = "";
				msg=mountMsg(decodeMessage(rc1), msg);
				msg=mountMsg(decodeMessage(rc2), msg);
				msg=mountMsg(decodeMessage(rc3), msg);
				msg=mountMsg(decodeMessage(rc4), msg);
				API.dbg("INFO : Printer is NOT ready to work: " + msg);
				//PosShowMessage(msg);
				if(rc1 != STATUS_OK)
				{
					returnValue = rc1;
				}
				else if( rc4 != STATUS_OK)
				{
					returnValue = rc4;
				}	
				else if(rc3 != STATUS_OK)
				{
					returnValue = rc3;
				}
				else if(rc2 != STATUS_OK)
				{
					if(rc2 == STATUS_PAPER_NEAR_END)
					{
						returnValue = STATUS_PAPER_NEAR_END;
					}
					else 	if(rc2 == STATUS_PAPER_OUT)
					{
						returnValue = STATUS_PAPER_OUT;
					}
					else
					{//should not be...
						API.dbg("Printer Paper Status error, but not near end or low.");
						returnValue = rc2;
					}	
				}
				break;
			} 
			else 
			{
				API.dbg("INFO : Printer is ready to work.");
				break;
			}
		}
	}
	catch (ex) 
	{
		PosShowMessage("Could not check printer status, due to: " + ex);
	}
	
	if(bScriptCall)
	{//called from script. Return status
		API.dbg("status returned is: "+returnValue);
		if(endofDayReportCheck == true)
		{
			return returnValue;
		}
		else
		{
			if(!PosCheckParameter("Kiosk","PrinterStatusCheckOff","1"))
			{
				return returnValue;
			}
			else //not check printer status always return true
			{
				return true
			}
		}
	}
	else
	{
		if(returnValue != 0 && !PosCheckParameter("Kiosk","PrinterStatusCheckOff","1"))  //error and printer status code enabled
		{
			return false;
		}
		else
		{	
			return true;
		}
	}

		
	/** decodeMessage
	 * 
	 * @brief - Decodes the message.
	 * @return - Error message.
	 * @since - PLE-446 - Generic implementation to detect the printer status.
	 */
	function decodeMessage(rc) 
	{
		if (STATUS_OK==rc) 
		{
			return null;
		} 
		else if (STATUS_NOT_AVAILABLE==rc)
		{
			return "Printer is offline or not available in the network.";
		} 
		else if (STATUS_PAPER_NEAR_END==rc)
		{
			return "Paper is near end in the printer.";
		} 
		else if (STATUS_PAPER_OUT==rc)
		{
			return "Printer is out of paper.";
		} 
		else if (STATUS_DOOR_OPEN==rc)
		{
			return "Printer cover is opened.";
		} 
		else if (STATUS_PAPER_JAM==rc)
		{
			return "Paper is jammed in the printer.";
		} 
		else if (STATUS_USER_INTERVENTION==rc)
		{
			return "Printer error, human intervention is required.";
		} 
		else if (STATUS_API_UNAVAILABLE==rc) 
		{
			return "This feature is not available for the configured printer driver.";
		}
		return "Unknown printer error.";
	}
	
	/** sndRcvPrnCmd
	 * 
	 * @brief - Sends and receives the printer command. 
	 * @return - Encoded status.
	 * @since - PLE-446 - Generic implementation to detect the printer status.
	 */
	 function sndRcvPrnCmd(class) 
	 {
	 	API.dbg("handling command: "+class);
		const cmd = createCmd(class);						// Class command.
		const rc = PosSendPrinterCmd(cmd); 					// Sends the escape command to the default printer.
		if (rc == "-1") 
		{
			// This kind of RC is created by NewPOS
			return STATUS_API_UNAVAILABLE; 					// This API is not implemented in this printer driver.
		} 
		else if ((rc == null) || (rc.length == 0))
		{
			return STATUS_NOT_AVAILABLE; 					// Printer is disconnected or offline.
		} 
		else 
		{
			//
			// ALL CHECKS BELOW MAY DEPEND ON THE PRINTER DRIVER IMPLEMENTATION
			//
			const charCode = rc.charCodeAt(0);
			API.dbg("charCode is: "+charCode);
			if (charCode == 0) 
			{
				return STATUS_NOT_AVAILABLE; 				// Printer is disconnected or offline.
			} 
			else 
			{
				// Perfect status sequence tested using printer model: BT-T080 is: 22 18 18 18
				if (class == CLASS_PRINTER_STATUS) 
				{//mz 17.06.09: we  ignore the drawer kickout connector, the customer display and the undefined values (bits: 2, 5 and 6)
					if (charCode != 18 && charCode != 22 && charCode != 40 && charCode != 82 && charCode != 86 && charCode !=  118 ) 
					{
						return STATUS_NOT_AVAILABLE;
					}
				} 
				else if (class == CLASS_BUSY_STATUS) 
				{
					if (charCode & BIT_2) 
					{
						return STATUS_DOOR_OPEN;
					} 
					if( (charCode & BIT_5) && (charCode & BIT_6) )
					{//do nothing this is an error for paper out. will be done with the CLASS_PAPER_SENSOR_STATUS
						API.dbg("Printer Status (BUSY STATUS) was paper out.");
					}
					else if (charCode != 18 && charCode != 22 && charCode !=  40 && charCode !=  56) 
					{//mz 17.06.09: we ignore Paper feed button status and printing stop due to a paper out (will be covered later)
						return STATUS_USER_INTERVENTION;
					}
				} 
				else if (class == CLASS_ERROR_STATUS) 
				{
					if (charCode & BIT_5 || charCode & BIT_3) 
					{
						return STATUS_PAPER_JAM;
					} 
					else if (charCode & BIT_6) 
					{
						return STATUS_ERROR_UNKNOWN;
					} 
					else if (charCode != 18) 
					{
						return STATUS_USER_INTERVENTION;
					}
				} 
				else if (class == CLASS_PAPER_SENSOR_STATUS) 
				{
					if ((charCode & BIT_5) && (charCode & BIT_6)) 
					{
						return STATUS_PAPER_OUT;
					}
					else if ((charCode & BIT_2) && (charCode & BIT_3)) 
					{
						return STATUS_PAPER_NEAR_END;
					}					 
					else if (charCode != 18) 
					{
						return STATUS_USER_INTERVENTION;
					}
				}
			}
			return STATUS_OK;
		}
	}
	
	/** createCmd
	 * 
	 * @brief - Creates the real time status transmission command. The command sequence has been extracted 
	 *          from the programming guide manual of the printers: Wincor TH230 and BT-T080 both models were 
	 *          used in the Europen kiosk solution.
	 * @return - real time status command.
	 * @since - PLE-446 - Generic implementation to detect the printer status.
	 */
	 function createCmd(class) 
	 {
		var DLE 		= 0x10;
		var EOT 		= 0x04;
		var END_OF_CMD 	= 0x00;
		var cmd = new StringBuffer();
		
		cmd.append(String.fromCharCode(DLE));
		cmd.append(String.fromCharCode(EOT));
		cmd.append(class);
		cmd.append(String.fromCharCode(END_OF_CMD));
		
		return cmd.toString();
	}
	
	/** getPrnId
	 * 
	 * @brief - Gets the first PRN id.
	 * @return - Service id, -1 when the service type has not been found.
	 */
	function getFirstServiceId(srvType) {
		var hlp 			= new BusinessObjectHelper;
		var prolog			= "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n";
		var posDataPath		= hlp.PosGetDataDir();
		var posDbName		= hlp.PosGetPosDbName();
		var posDbFullName	= (posDataPath + "/" + posDbName);
		var xmlBuffer 		= hlp.PosReadFile(posDbFullName);
		if (xmlBuffer != null) {
			xmlBuffer = xmlBuffer.replace("<?xml","<!-- bug_336551"); //spidermonkey bugzilla 336551
			xmlBuffer = xmlBuffer.replace("?>","bug_336551 -->");
			var posDb = new XML(xmlBuffer);
			var srvId = 0;
			for each(service in posDb.Services.Service) {
				if ((service.@type == srvType) && (service.@startonload == "true")) {
					for each(adaptor in service.Adaptors.Adaptor) {
						if ((adaptor.@name == "npAdpRpr") && (adaptor.@startonload == "true")) {
							return srvId;
						}
					}
				}
				srvId++;
			}
		}
		return -1;
	}
	
	/**mountMsg
	 *
	 * @brief - This function is required for not show the message twice.
	 * @return - unique message.
	 * @since - PLE-446 - Generic implementation to detect the printer status.
	 */	
	function mountMsg(inMsg, outMsg) 
	{
		if ((inMsg != null) && (outMsg.indexOf(inMsg)<0)) 
		{
			return (outMsg + "\n" + inMsg);
		}
		return outMsg;
	}	
}

/*
 * @brief - This function implements the DTSTORE for DT 
 * we need it because of family pack for NL . ON DT we cannot have discount tranzaction.
 * Return - rval - True
*/
function DtStore()
{

	var hlp=new BusinessObjectHelper;	
	var familypackflag = hlp.findParamInSectionWide("FamilyPackDiscountActive","FamilyPack")
	
	if(familypackflag == "1")
	{  //for familypackdiscount
		  PosSetSessionProperty("familypackForDTSTORE", "1", false); //this is used in order to not run the famlypackdiscount() in the posdotataljs
		  PosDoBackFromTotal(); //back from total
		  //make the total and store the order
		  if(Country == "DE")
		  {
			PosDoTotalJS("1",TENDER_SCREEN_NBR_DE, STORE_SCREEN_NBR_DE, "NOPREVIEW|SAVE");
		  }
		  else
		  {
			PosDoTotalJS("1",TENDER_SCREEN_NBR, STORE_SCREEN_NBR, "NOPREVIEW|SAVE");
		  }
		  PosDoStore();
		  PosSetSessionProperty("familypackForDTSTORE", "0", false); //reset the session variable so that for other orders we can have the family pack discount
	 }
	 else
	 {
		PosDoStore();
	 }
	 return true;
}


/*
 * @brief - This function implements the family pack discount
 * it use the onProductDBIteration hook for getting the necessary inforomation from product-db
 * Return - rval - True
*/
function familyPackDiscount()
{
 
   	 var doDiscount= false;
    //the number of each value meal should be reseted at the begining of these function to ensure that we not add the old qunatity too
	familyPackKM = 0;
	familyPackSM = 0;
	familyPackVM = 0;
	familyPackDiscount1Amount =new BigDecimal(0.00);
	familyPackDiscount2Amount =new BigDecimal(0.00);
	
	PosSetSessionProperty("familypackForDTSTORE", "0", false);
	var hlp = new BusinessObjectHelper;
	
	
	//test if the familypackdiscount is enable
	if(hlp.findParamInSectionWide("FamilyPackDiscountActive","FamilyPack")=="1") //family pack is active
	{
		//get the current discount amounts
		var discount1 = hlp.findParamInSectionWide("FamilyPackDiscountAmount1","FamilyPack");
		var discount2 = hlp.findParamInSectionWide("FamilyPackDiscountAmount2","FamilyPack");
		if(discount1 == null)
		{
			discount1 =1.4;
		}
		if(discount2 == null)
		{
		 	discount2 =1.15;
		}
		
		var familyPackDiscDescription = hlp.findParamInSectionWide("FamilyPackDiscountName","FamilyPack"); 
		if(familyPackDiscDescription == null)
		{
			familyPackDiscDescription = "FamilyPack D.";
		}
		
		currView = hlp.getCurrentView();

		xmlView= new XML(currView);
		API.dbg("familyPackDiscount currentsaleview: " +xmlView);
		var items = xmlView.ItemView;
		//calculate the quantity of each family value meal
		for each (item in items)
		{
			var prodCode = item.productCode+ "";
			arrProdCode= new Array();
			arrProdCode[0]= prodCode;
			//get the product information
			hlp.iterateProductDB(arrProdCode, prodCode);
			
		}

		familyPackDiscount2Amount = new BigDecimal(0.00);
		familyPackDiscount2TC = 0;
		familyPackDiscount1Amount = new BigDecimal(0.00);
		familyPackDiscount1TC = 0;

		if(Number(familyPackKM) < 0)
		{
			familyPackKM = 0;
		}

		if(Number(familyPackVM) < 0)
		{
			familyPackVM = 0;
		}

		if(Number(familyPackSM) < 0)
		{
			familyPackSM = 0;
		}

		API.dbg("familyPackKM " + familyPackKM);
		API.dbg("familyPackVM " + familyPackVM);
		API.dbg("familyPackSM " + familyPackSM);
		if(Number(familyPackKM) > 0)
		{
			if(Number(familyPackKM) <= Number(familyPackVM) )
			{
				familyPackDiscount1TC = Number(familyPackKM);
				familyPackDiscount1Amount = familyPackDiscount1Amount.add(Number(discount1) * familyPackDiscount1TC);
			}else if(Number(familyPackKM) > Number(familyPackVM) )
			{
				familyPackDiscount1TC = Number(familyPackVM);
				familyPackDiscount1Amount = familyPackDiscount1Amount.add(Number(discount1) * familyPackDiscount1TC);
			}

			if(Number(familyPackKM - familyPackVM) >= Number(familyPackSM) )
			{
				familyPackDiscount2TC =Number(familyPackSM);
				familyPackDiscount2Amount = familyPackDiscount2Amount.add(Number(discount2) * familyPackDiscount2TC);
			}else if(Number(familyPackKM - familyPackVM) < Number(familyPackSM) && Number(familyPackKM - familyPackVM) > 0)
			{
				familyPackDiscount2TC =Number(familyPackKM - familyPackVM);
				familyPackDiscount2Amount = familyPackDiscount2Amount.add(Number(discount2) * familyPackDiscount2TC);
			}
		}

		if(Number(familyPackDiscount1Amount) > 0 || Number(familyPackDiscount2Amount) > 0)
		{
			PosSetSessionProperty ("familypackCurrentDiscount", "1", false);
			//make the discount
			familyPackDiscount1Amount = familyPackDiscount1Amount.add(familyPackDiscount2Amount);
			PosDoDiscount("0","1","1", API.formatNumber(Number(familyPackDiscount1Amount), "####0.00", 8),familyPackDiscDescription);
			PosSetSessionProperty ("familypackCurrentDiscount", "2", false); //the value after discount
		}
		
	}
	return true;
}
/* 6.1.16 version function US specific, not neeeded at least for the moment
function Rec_NP_TaxFilterJS(items,hlp) {
	for each (OrderItem in items) {
		var prodString = hlp.getProductDescr(OrderItem.@code);
		if(prodString != null) {
			var prodXML = new XML(prodString);
			OrderItem.@applyTax = (prodXML.@familyGroup == "GIFT_COUPON" || prodXML.@familyGroup == "NON_PRODUCT");
			//PosShowMessage ("prod " + OrderItem.@code + " tax " + OrderItem.@applyTax);
		}
		if(OrderItem.Item.length() != 0) {
			Rec_NP_TaxFilterJS(OrderItem.Item,hlp);
		}
	}
}
function Rec_OTSR1_TaxFilterJS(items,hlp) { // 4 dolars 
	for each (OrderItem in items) {
		var prodString = hlp.getProductDescr(OrderItem.@code);
		if(prodString != null) {
			var prodXML = new XML(prodString);
			if(prodXML.@familyGroup != "GIFT_COUPON" && prodXML.@familyGroup != "NON_PRODUCT") {
				OrderItem.@applyTax = "false";
			}
			if(OrderItem.Item.length() != 0) {
				Rec_OTSR1_TaxFilterJS(OrderItem.Item,hlp);
			}
		}
	}
}
function Rec_OTSR2_IsAllSoftDrink(items,hlp) { // soft drink
	for each (OrderItem in items) {
		if(OrderItem.@quantity <= 0) {
			continue;
		}
		var prodString = hlp.getProductDescr(OrderItem.@code);
		if(null == prodString) {
			return false;
		}
		prodXML = new XML(prodString);
		if(prodXML.@familyGroup != "GIFT_COUPON" && prodXML.@familyGroup != "NON_PRODUCT") {
			if(prodXML.Parameter.length() == 0) {
				return false;
			}
			var IsSoftDrink = prodXML.Parameter.(@name == "isSoftDrink");
			if(IsSoftDrink.@value != "true") {
				return false;
			}
		}
		
		if(OrderItem.Item.length() != 0) {
			if(!Rec_OTSR2_IsAllSoftDrink(OrderItem.Item,hlp)) {
				return false;
			}
		}
		
	}
	return true;
}

function TaxFilterJS(sView) {
	//PosShowMessage (">> View = " + sView);
	var view = new XML(sView);
	if(view.Tax.@rule == "NP") {
		//PosShowMessage ("NP");
		var hlp = new BusinessObjectHelper;
		Rec_NP_TaxFilterJS(view.Items.Item,hlp);
	} else 	if(view.Tax.@rule == "OTSR") {
		//PosShowMessage ("OTSR");
		if(Number(view.@amount) <= 4.00) {
			//PosShowMessage ("<= 4.00");
			var hlp = new BusinessObjectHelper;
			if(!Rec_OTSR2_IsAllSoftDrink(view.Items.Item,hlp)) {
				Rec_OTSR1_TaxFilterJS(view.Items.Item,hlp);
			}
		}
	}
	sView = view.toString();
	//	PosShowMessage ("<< View = " + sView);
	return sView;
}

*/

/** PosCanVoidSaleJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosCanVoidSaleJS</b>\n
 * This BC checks if it's possible to void a sale!\n
 * In a workflow sequence it is called:<b>PosCanVoidSaleJS</b>\n
 * In java script it should be called:<b>PosCanVoidSaleJS()</b>\n
 * This BC does not require parameters.\n
 * Return - rval - True if possible
 */
function PosCanVoidSaleJS() {

	var hlp = new BusinessObjectHelper;
	
	var lastView = hlp.getLastSaleView();
	if(lastView == null) {
		lastView = hlp.getCurrentView();
	}
	if(lastView == null) {
		PosShowMessage("MSG_BC_NO_ORDER_TO_VOID");
		return false;
	}
		
	var view = new XML(lastView);
	if((view.@transactionKind == ACC_OT_MANAGER) || (view.@transactionKind == ACC_OT_CREW)) {
		PosShowMessage("MSG_BC_VOID_CREW_MEAL");
		return false;
	}
	if((view.@transactionKind != ACC_OT_SALE) && (view.@transactionKind != ACC_OT_DISCOUNT)) {
		PosShowMessage("MSG_BC_VOID_LAST_SALE");
		return false;
	}
		
	if((view.@saleStatus == SALE_STATUS_CURRENT_VOIDED) || (view.@saleStatus == SALE_STATUS_LAST_VOIDED)) {
		PosShowMessage("MSG_BC_OVERRUNG_ORDER");
		return false;
	}
	if(view.@saleStatus == SALE_STATUS_STORED) { 
		PosShowMessage("MSG_BC_NO_ORDER_TO_VOID"); 
		return false; 
	} 
	
	var allowed = true;

	var items = view.ItemView;
	if(items.length() != 0) {
		var giftCard = items.((quantity > 0) && (familyGroup == GIFT_COUPON) && (productType == NON_FOOD_PRODUCT) && (category == PAPER));
		allowed=(giftCard.length() == 0);
		if(!allowed) {
			PosShowMessage("MSG_BC_OVERRING_GC");
		}
	}	
	var tenders	= view.ItemTenderView;
	if((allowed) && (tenders.length() != 0)) {
		var electronicPayment = tenders.(cat == "TENDER_ELECTRONIC_PAYMENT");
		allowed=(electronicPayment.length() == 0);
		if(!allowed) {
			PosShowMessage("MSG_BC_OVERRING_CASHLESS");
		}
	}
	return allowed;
}

/** CanSellGiftCardJS
 *
 * @brief - This function implements the BC,Business Component: <b>CanSellGiftCardJS</b>\n
 * This BC checks if it's possible to sell gift cards!\n
 * In a workflow sequence it is called:<b>CanSellGiftCardJS</b>\n
 * In java script it should be called:<b>CanSellGiftCardJS</b>\n
 * Return - rval - true if possible
 */
function CanSellGiftCardJS()
{
	// check if it's refund or waste
	if(PosCheckTransactionKind("1") || PosCheckTransactionKind("2")) {
		return(false);
	}
	if(PosCheckSessionProperty("POD","DRIVE_THRU") || PosCheckSessionProperty("POD","WALK_THRU")) {
		return(true);
	}
	if(PosCheckSessionProperty("POD","HOT")) {
		return(true);
	}
	return(PosIsCashlessLoadedJS());
}

/** CanReceiveCouponsJS()
 *
 * @brief - This function implements the BC,Business Component: <b>CanReceiveCouponsJS</b>\n
 * This BC checks if it's possible to receive coupons as payment.\n
 * In a workflow sequence it is called:<b>CanReceiveCouponsJS</b>\n
 * In java script it should be called:<b>CanReceiveCouponsJS</b>\n
 * Return - rval - true if possible
 */
function CanReceiveCouponsJS()
{
	var hlp = new BusinessObjectHelper;
	
	var curView = hlp.getCurrentView();
	if(curView == null) {
		return(auxShowMessageClearCalc("MSG_BC_NO_ORDER_IN_PROGRESS"));
	}
	var view = new XML(curView);
	var items = view.ItemView;
	if(items.length() == 0) {
		return(true);
	}
	var giftCard = items.((quantity > 0) && (familyGroup == GIFT_COUPON) && (productType == NON_FOOD_PRODUCT) && (category == PAPER));
	if(giftCard.length() != 0) {
		return(auxShowMessageClearCalc("MSG_BC_DISCOUNT_GC"));
	}
	var giftOrCoupon = items.((quantity > 0) && (familyGroup == GIFT_COUPON));
	if(giftOrCoupon.length() != 0) {
		return(auxShowMessageClearCalc("MSG_BC_DISCOUNT_COUPON"));
	}
	var NonProduct = items.((quantity > 0) && (isGrillLine != "true") && (familyGroup == NON_FOOD_PRODUCT));
	if(NonProduct.length() != 0) {
		return(auxShowMessageClearCalc("MSG_BC_DISCOUNT_NON_PRODUCT"));
	}
	return(true);
}

/**PosCanApplyPromoOrder
 *
 * @brief - This BC verifies if it's possible to promo an order
 * Return - rval - true if allowed to continue
 */
function PosCanApplyPromoOrder()
{
	var hlp = new BusinessObjectHelper;
	var curView = hlp.getCurrentView();
	if(curView == null) {
		return(true);
	}
	var view = new XML(curView);
	if(null == view) {
		return(true);
	}
	if((view.@transactionKind != ACC_OT_SALE) && (view.@transactionKind != ACC_OT_DISCOUNT) 
			&& (view.@transactionKind != ACC_OT_MANAGER) && (view.@transactionKind != ACC_OT_CREW)) {
		return(true);
	}
	
	if (hasFloatPriceItems()) {
		// SQC-443 - By KFG
		PosShowMessage("MSG_BC_INVPROMO");
		return false;
	}
	
	var items=view.ItemView;
	if(null == items) {
		return(true);
	}
	var giftCardLines=0;
	var i;
	for(i=0; i < items.length(); i++) {
		var item=items[i];
		if((item.quantity > 0) && (item.familyGroup == GIFT_COUPON) && (item.productType == NON_FOOD_PRODUCT) && (item.category == PAPER)) {
			// Gift Card not allowed
			giftCardLines++;
		}
	}
	if(giftCardLines == items.length()) {
		PosShowMessage("MSG_BC_PROMO_GC_ORDER");
		return(false);
	}
	if(giftCardLines > 0) {
		PosShowMessage("MSG_BC_PROMO_GC");
		return(false);
	}
	return(true);
	
	/**hasFloatPriceItems
	 *
	 * @brief - Verifies if the current order has any float price item.
	 * @return - TRUE - if the order has at least one float price item.
	 * @since - NPS-5384 & SQC-443
	 * @author - Kalil
	 */
	function hasFloatPriceItems() {
		var curView = hlp.getCurrentView();	
		if (curView != null) {
			var view = new XML(curView);
			var items = view.ItemView;
			for (var i=0;i<items.length();i++) {
				if ((new Number(items[i].isFloatPrice)>0) && (new Number(items[i].quantity)>0)) {
					return true;
				}
			}
		}
		return false;
	}
}

/** PosRecallByPreviewNotDTJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosRecallByPreviewNotDTJS</b>\n
 * This BC does the auto recall!\n
 * In a workflow sequence it is called:<b>PosRecallByPreviewNotDTJS</b>\n
 * In java script it should be called:<b>PosRecallByPreviewNotDTJS</b>\n
 * Return - rval - true if possible
 */
function PosRecallByPreviewNotDTJS()
{
	if(!PosCheckState("POS_OpLogged")) {
			PosShowMessage("MSG_BC_NOTOPENFORSALE");
			return(false);
	}
	
	if(!PosCheckSessionProperty("POD","DRIVE_THRU")) {
		if(!PosCheckCashDrawer()) {
			PosShowMessage("MSG_BC_DRAWEROPENED");
			return(false);
		}
		
		var Recall_Result = PosRecallNextOrder("RecallByPreview");
		PosShowScreen(BYPREVIEW_SCREEN_NBR);
		return(true);
	}
	return(false);
}

/** PosDoAutoRecallJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosDoAutoRecall</b>\n
 * This BC does the auto recall!\n
 * In a workflow sequence it is called:<b>PosDoAutoRecallJS</b>\n
 * In java script it should be called:<b>PosDoAutoRecallJS</b>\n
 * Return - rval - true if possible
 */
function PosDoAutoRecallJS()
{
	var RecalledNotDT=0;
	if(!PosCheckSessionProperty("POD","DRIVE_THRU")) {
		if(PosCheckParameter("UserInterface","autoPreview","true")) {
			RecalledNotDT=1;
		}
		else {
			// autoPreview = false
			return(false);
		}
	}
	
	if(RecalledNotDT==0) { // Recalled  DT
		if(!PosCheckSessionProperty("POD","DRIVE_THRU") && !PosCheckSessionProperty("POD","WALK_THRU")) {
			return(false);
		}
	}
	
	if(PosCheckParameter("UserInterface","DDTsupport","true") || (RecalledNotDT==1)) { // RecalledNotDT==1 autoPreview = true
		if(!PosCheckCashDrawer()) {
			return(false);
		}
		PosRecallNextOrder("RecallByPreview");
		PosShowScreen("9998");
		return(true);
	}
	if(PosCheckParameter("OperationMode","autoRecall","true")) {
		if(PosCheckSessionProperty("saleRecalled","true")) {
			var ctx=new SessionContext;
			if(!PosCheckCashDrawer()) {
				return(false);
			}
			if(PosRecallNextOrder()) {
				var hlp = new BusinessObjectHelper;
				var curView = hlp.getCurrentView();
				if(curView == null) {
					return(true);
				}
				var view = new XML(curView);
				if(null == view) {
					return(true);
				}
				PosDoTotal();
				if(view.@transactionKind == ACC_OT_SKIP_CAR) {
					PosDoTenderJS(0,-1,'NOPREVIEW');
				}
				else {
				    if(Country =="DE")
					{
						PosShowScreen(TENDER_SCREEN_NBR_DE);
					}
					else
					{
						PosShowScreen(TENDER_SCREEN_NBR);
					}
						
				}
				return(true);
			}
		}	
	}

	return(false);
}

/** PosDoNextOrderJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosDoNextOrderJS</b>\n
 * This BC gets the next order!\n
 * In a workflow sequence it is called:<b>PosDoNextOrderJS</b>\n
 * In java script it should be called:<b>PosDoNextOrderJS</b>\n
 * Return - rval - true if possible
 */
function PosDoNextOrderJS()
{
	
	if(PosCheckSessionProperty("POD","DRIVE_THRU") || PosCheckSessionProperty("POD","WALK_THRU")) {
		if(PosCheckSessionProperty("saleRecalled","true")) {
			if(!PosCheckCashDrawer()) {
				PosShowMessage("MSG_BC_DRAWEROPENED");
				return(false);
			}
			if(PosRecallNextOrder("next")) {
				PosDoTotal();
				if(Country =="DE")
				{
					PosShowScreen(TENDER_SCREEN_NBR_DE);
				}
				else
				{
					PosShowScreen(TENDER_SCREEN_NBR);
				}
				return(true);
			}
			else {
				if(PosNotATransactionInProgress(true)) {
					var ctx=new SessionContext;
					PosShowScreen(ctx.get("baseScreenId"));
				}
			}
		}	
	}
	return(false);
}

/** PosDoRecallOrderJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosDoNextOrderJS</b>\n
 * This BC gets the next order!\n
 * In a workflow sequence it is called:<b>PosDoNextOrderJS</b>\n
 * In java script it should be called:<b>PosDoNextOrderJS</b>\n
 * Return - rval - true if possible
 */
function PosDoRecallOrderJS(type)
{
	
	var ctx=new SessionContext;
	if(!PosCheckCashDrawer()) {
		PosShowMessage("MSG_BC_DRAWEROPENED");
		return(false);
	}
	if(PosRecallNextOrder(type)) {
		var hlp = new BusinessObjectHelper;
		var curView = hlp.getCurrentView();
		if(curView == null) {
			return(true);
		}
		var view = new XML(curView);
		if(null == view) {
			return(true);
		}
		PosDoTotal();
		if(view.@transactionKind == ACC_OT_SKIP_CAR) {
			PosDoTenderJS(0,-1,'NOPREVIEW');
		}
		else {
			if(Country =="DE")
			{
				PosShowScreen(TENDER_SCREEN_NBR_DE);
			}
			else
			{
				PosShowScreen(TENDER_SCREEN_NBR);
			}
		}
		return(true);
	}
	else {
		if(PosNotATransactionInProgress(true)) {
			PosShowScreen(ctx.get("baseScreenId"));
		}
	}
	return(false);
}

/**PosPromoOrderJS
 *
 * @brief - This BC promo-es an order
 * Return - rval - true if allowed to continue
 */
function PosPromoOrderJS(level,sigleSignOn,promoType,preview,choices)
{
	if(PosNotATransactionInProgress(true)) {
		PosShowMessage("MSG_BC_NO_ORDER_IN_PROGRESS");
		return(false);
	}
	if(!PosCanApplyPromoOrder()) {
		// Can't promo
		return(false);
	}
	PosSetSessionProperty("discountForPromoOrder","true","false");
	
	if(!PosCheckSessionProperty("getAuthForForPromoOrder","false")) {
		if(!PosGetAuthorization(level,sigleSignOn)) {
			// Not Authorized
			PosSetSessionProperty("discountForPromoOrder","false","false");
			return(false);
		}
	}
	// Handle choices...
	if(!PosAutoChoice()) {
		PosSetSessionProperty("discountForPromoOrder","false","false");
		return(false);
	}
	if((choices != undefined) && (choices != null)) {
		var choiceArray=choices.split(",");
		if(choiceArray != null) {
			var i=0;
			for(;i < choiceArray.length; i++) {
				var choice_screen=choiceArray[i].split("|");
				if(choice_screen != null) {
					if(!PosCheckChoice(choice_screen[0],choice_screen[1],true,"MSG_BC_SALE_INCOMPLETE")) {
						PosSetSessionProperty("discountForPromoOrder","false","false");
						return(false);
					}
				}
			}
		}
	}
	if(PosCheckSessionProperty("POD","DRIVE_THRU") || PosCheckSessionProperty("POD","WALK_THRU")) {
		// Drive Thru
		PosSetSaleType(1);
	}
	else {
		if(!PosItemSelection("eatin.png|takeout.png|cancel.png","0|1|2","MSG_BC_PROMOORDER_TITLE","MSG_BC_PROMOORDER_MESSAGE")) {
			PosSetSessionProperty("discountForPromoOrder","false","false");
			return(false);
		}
		var ctx = new SessionContext;
		var ret=Number(ctx.get("SelectedButtonValue"));
		if((ret != 0) && (ret != 1)) { 
			return(false);
		}
		PosSetSaleType(ret);
	}
	if(!PosDoPromoItem(promoType)) {
		PosSetSessionProperty("discountForPromoOrder","false","false");
		return(false);
	}
	PosHandleCalculatorButton("clear");
	if(!PosDoTotal()) {
		PosSetSessionProperty("discountForPromoOrder","false","false");
		return(false);
	}
	PosSetSessionProperty("discountForPromoOrder","false","false");
	if(PosCheckSessionProperty("workingMode","orderTaker") || (PosCheckSessionProperty("workingMode","both") && !PosCheckSessionProperty("saleRecalled","true"))) {
		if(!PosDoStore()) {
			return(false);
		}
	}
	else {
		if(!PosDoTender(0,-1)) {
			return(false);
		}
		var success= false;
		if (Country == "RU") 
		{ 
			if(PosDoEndOfSaleNoDrawer(true)) // do not open cash drawer if there was an error durring the end of sale
			{
				success = PosEndOfSaleOpenCashDrawer();
			}
		}
		else //open cash drawer in all cases
		{
			success = PosDoEndOfSale(true);
		}
		
		if(!success) {
			return(false);
		}
		PosCreateReceiptJS(0,"VIEW","receipt@reports.nps",preview)
		
		if(PosCheckSessionProperty("pickListAutomaticPrint","on")) {
			var hlp = new BusinessObjectHelper;
			var showCanceledItems = hlp.findParamInSectionConfig("showCanceledItems","UserInterface");
			PosCreateReport("FULLCONSVIEW","reportPickList@reports.nps","NOPREVIEW",showCanceledItems);
		}
		
	}
	var ctx=new SessionContext;
	PosShowScreen(ctx.get("baseScreenId"));
	return(true);
}

/**PosDoSaleSizeJS
 *
 * @brief - This BC sells an item
 * Return - rval - true if allowed to continue
 */
function PosDoSaleSizeJS(size,productCode)
{
	if(typeof(onDoSaleJS) == "function") {
		if(!onDoSaleJS()) {
			return(true);
		}
	}
	var ctx=new SessionContext;
	if(PosNotATransactionInProgress(true)) {
		//6.1.17 RC16 sample scripts and release notes
		PosSetSessionProperty("CASHLESS","","true");
		if(typeof(onSaleStartJS) == "function") {
			if(!onSaleStartJS()) {
				return(true);
			}
		}
		// Sale not started as yet...
		if(!PosCheckCashDrawer()) {
			// Drawer open
			PosShowMessage("MSG_BC_DRAWER_OPENED");
			ctx.remove("selectedProductWithSize");
			return(true);
		}
		// *** Updated In Line With Gap Analysis Technical Notes ***
		// *** Chris Appleton, 23rd July 2008 ***
		// Checks whether this order can be a multi-order
		// var trxType=Number(ctx.get("transactionSaleType"));
		// if(	(trxType != 1) && 
		//   	(trxType != 2) && 
		//   	(PosCheckSessionProperty("POD","DRIVE_THRU") ||
		//	PosCheckSessionProperty("POD","WALK_THRU")) && 
		//   	PosCheckSessionProperty("workingMode","cashier") &&
		//   	PosCheckSessionProperty("bMultiOrder",false)) {
			// Can be a Multi-Order
		//	var multiOrder=false;
		//   	if(PosCheckSessionProperty("firstSaleDone",true)) {
				// Asks for selection
		//		if(!PosItemSelection("multiorderthis.png|neworder.png|cancel.png","1|0|2","Question","MSG_BC_ISNEWORDER") ||
		//			Number(ctx.get("SelectedButtonValue")) > 1) {
		//			ctx.remove("selectedProductWithSize");
		//			return(true);
		//		}
				multiOrder=(Number(ctx.get("SelectedButtonValue"))==1)?true:false;
		//	}
		//	PosMultiOrder(multiOrder);
		//}
	}
	if(Number(size) >= 0) {
		PosSizeSelection(size);
	}

	// oi 26.01.2010 add for 6.1.17
	PosDoMultiChoice(productCode);
	
	// Is this product a Choice solution?
	var ret=true;
	if(!PosDoChoice(productCode)) {
		if(PosCheckSessionProperty("isSmartReminderON","TRUE")) {
			PosEndSmartReminder();
			PosShowGrillFloatScreen();
		}

		// Sale did not end with a choice
		if(PosDoSale(productCode)) {
			// Are there choices that can be solved?
			if(!PosCheckSessionProperty("POD","CSO")) {
				PosAutoChoice();
			}
			ctx.set("firstSaleDone",true,true);
		}
		else {
			ret=false;
		}
		//PosDoQuantum(-1);
		ctx.remove("selectedProductWithSize");
	}
	else {
		PosConvertProduct();
	}  
	return(ret);
}

/**PosDoSaleJS
 *
 * @brief - This BC sells an item
 * Return - rval - true if allowed to continue
 */
function PosDoSaleJS(productCode)
{
	var ret=PosDoSaleSizeJS(-1,productCode);
	if(ret) {
		return(true);
	}
	if( PosCheckSessionProperty("dedicatedCOD","false") &&
		!PosCheckSessionProperty("activatedCOD","0") &&
		PosCheckSessionProperty("POD","DRIVE_THRU") && 
		PosCheckSessionProperty("workingMode","orderTaker|both")) {
		var ctx=new SessionContext;
		while(!ret) {
			var cod=ctx.get("activatedCOD");
			if(cod<0) {
				var newCod=String(-cod);
				PosSetSessionProperty("activatedCOD",newCod,"true")
				PosCommStatusCOD("MSG_BC_ERRORCONFIGCOD");
				PosDisplayText("MSG_BC_ROUTEDCOD",1,true,false,newCod);
				ret=PosDoSaleSizeJS(-1,productCode);
			}
			else {
				ret=true;
			}
		}
	}
	// Refresh screen (might have to refresh after a COD colision)
	PosRefreshButtons();
	return(ret);	
}

/**PosDoEndOfSaleJS
 *
 * @brief - This BC ends the sale in a tendering process
 * Return - rval - true if should stop execution
 */
function PosDoEndOfSaleJS(noAutoRecall,flags,kioskDup)
{

	/* flags */
	var hlp = new BusinessObjectHelper;
	var closeTenderForGlobal = hlp.findParamInSectionWide("CloseTenderForGlobalServe","OperationMode");
	var storedbPath = "Configurations.Configuration.(@type==\"POS\").Section.(@name==\"OperationMode\").Parameter.(@name==\"doubleCrewServeOnProduction\").@value";
	var posdbPath = "Services.Service.(@type==\"POS\").Configuration.(@imports==\"POS\").Section.(@name==\"OperationMode\").Parameter.(@name==\"doubleCrewServeOnProduction\").@value";
	var bumpBar = getConfigValue(storedbPath, posdbPath);

	var familypackflag = hlp.findParamInSectionWide("FamilyPackDiscountActive","FamilyPack");
	
	var firstPrintReceipt = hlp.findParamInSectionWide("CoinDispPrintReceiptOrder","Receipt") == "true"; //true if is set to give the change after printing
	var firstPickListReceipt = hlp.findParamInSectionWide("CoinDispPrintPickList","Receipt") == "true"; //true if is set to give the change after printing
	var coinDispCalled = false; //ensure that we do not call twice the dispense coin function
	
	var success = false;
	if (Country == "RU") 
	{ 
		if(PosDoEndOfSaleNoDrawer(true)) // do not open cash drawer if there was an error durring the end of sale
		{
			success = PosEndOfSaleOpenCashDrawer();
		}
	}
	else //open cash drawer in all cases
	{
		success = PosDoEndOfSale(true);
	}
	//what to do after the end of sale if everyting was ok 
	if(success) {
		/*
		var hlp = new BusinessObjectHelper;
		var posinfo = hlp.getPOSState();
		API.dbg("posinfo "+posinfo );
		//var xmlInfo= new XML(posinfo);
		*/
		
		if( (familypackflag == "1") && (Number(familyPackDiscount1TC)+Number(familyPackDiscount2TC) > 0  ) )
		{
			if(runGetConfig_Eurecs == true)
			{
				PosCreateReport("CASH","GetConfigInfo@eurecs.nps", "", "");
			}
		    /* family pack section  */
			//we sold something so we need to add the number of discount into the telog files
		   //familyPackagediscount1TotalTC = Number(familyPackDiscount1TotalTC) + Number(familyPackDiscount1TC);
		   //familyPackagediscount2TotalTC = Number(familyPackDiscount2TotalTC) + Number(familyPackDiscount2TC);
			var sessionValue = StoreID +","+PosId+","+businessDate_Eurecs+","+familyPackDiscount1TC+","+ familyPackDiscount2TC;
			API.dbg("save session to tlog");
			PosSetSessionProperty ("familypack", sessionValue, true);
		}

		var ctx=new SessionContext;
		var hlp = new BusinessObjectHelper;
		
		var lastView = hlp.getLastSaleView();
		if(lastView == null) {
			lastView = hlp.getCurrentView();
		}
		var view = new XML(lastView);
		if(PosIsCashlessLoadedJS()) {
			PosCashlessEndOfSale();
		}
		// PosDispenseChangeJS function might not exist in a local configuration!
		if(view.@transactionKind != ACC_OT_SKIP_CAR) {
			if(kioskDup == null) {
				kioskDup=false;
			}
			//first we give the change and just after that we print the receipt
			if(firstPrintReceipt == false && typeof(PosDispenseChangeJS) == 'function')
			{
				PosDispenseChangeJS();
				coinDispCalled =true;
			}
			
			var storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"OrderNumber\").Parameter.(@name==\"FirstReceiptEmpty\").@value";
			var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"OrderNumber\").Parameter.(@name==\"FirstReceiptEmpty\").@value";
			var FirstReceiptEmpty = getConfigValue(storedbPath, posdbPath);

			if( FirstReceiptEmpty == "1")
			{
				PosSetSessionProperty("FirstReceiptEmpty", "1", false);
			}
			
			PosCreateReceiptJS(kioskDup,"VIEW","receipt@reports.nps",flags);
			PosSetSessionProperty("FirstReceiptEmpty", "0", false);

			//22.06.2010 OI set copy to true
			PosSetSessionProperty("CopyForDualPoint", "1", false);
			
			//08.03.2010 OI print second receipt or picklist on network printer

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PrinterList\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PrinterList\").@value";
			var PrinterList = getConfigValue(storedbPath, posdbPath);

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PrinterAliases\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PrinterAliases\").@value";
			var PrinterAliases = getConfigValue(storedbPath, posdbPath);

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PicklistWithBarCode\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PicklistWithBarCode\").@value";
			var PicklistWithBarCode = getConfigValue(storedbPath, posdbPath);

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PicklistOnSecondPrinter\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"PicklistOnSecondPrinter\").@value";
			var PicklistOnSecondPrinter = getConfigValue(storedbPath, posdbPath);

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"DuplicateReceiptWithBarCode\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"DuplicateReceiptWithBarCode\").@value";
			var DuplicateReceiptWithBarCode = getConfigValue(storedbPath, posdbPath);

			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"DuplicateReceiptOnSecondPrinter\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"DuplicateReceiptOnSecondPrinter\").@value";
			var DuplicateReceiptOnSecondPrinter = getConfigValue(storedbPath, posdbPath);


			storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"CashlessMerchantOnSecondPrinter\").@value";
			posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"PrintOnNetworkPrinter\").Parameter.(@name==\"CashlessMerchantOnSecondPrinter\").@value";
			var CashlessMerchantOnSecondPrinter = getConfigValue(storedbPath, posdbPath);
			
			API.dbg("PosDoEndOfSaleJS PrinterList: " + PrinterList + " PrinterAliases: " + PrinterAliases + " PicklistWithBarCode: " + PicklistWithBarCode + " PicklistOnSecondPrinter: " + PicklistOnSecondPrinter + " DuplicateReceiptWithBarCode: " + DuplicateReceiptWithBarCode + " DuplicateReceiptOnSecondPrinter: " + DuplicateReceiptOnSecondPrinter + " CashlessMerchantOnSecondPrinter: " + CashlessMerchantOnSecondPrinter);

			// ask for a barcode on the second receipt
			if(DuplicateReceiptWithBarCode == "1")
			{
				PosSetSessionProperty("SecondPrintOutWithBarCode", "1", false);
			}
			//print the second receipt
			if(DuplicateReceiptOnSecondPrinter == "1")
			{
				PosCreateReport("VIEW","receipt@reports.nps",flags + "|ALIAS","", PrinterAliases, PrinterList);
			}
			//Reset the Bar Code
			PosSetSessionProperty("SecondPrintOutWithBarCode", "0", false);
			
			//ask for a bar code on the picklist
			if(PicklistWithBarCode == "1")
			{
				PosSetSessionProperty("SecondPrintOutWithBarCode", "1", false);
			}
			//print a picklist on a printer in the network
			if(PicklistOnSecondPrinter == "1")
			{
				PosSetSessionProperty("PickListForORB", "1", false);
				PosCreateReport("VIEW","reportPickList@reports.nps",flags + "|ALIAS","", PrinterAliases, PrinterList);
				PosSetSessionProperty("PickListForORB", "0", false);
			}

			//Reset the Bar Code
			PosSetSessionProperty("SecondPrintOutWithBarCode", "0", false);

			//22.06.2010 OI reset copy to true
			PosSetSessionProperty("CopyForDualPoint", "0", false);
			
			if(firstPrintReceipt == true && typeof(PosDispenseChangeJS) == 'function')
			{
				PosDispenseChangeJS();
				coinDispCalled= true;
			}
		}
		if(PosCheckSessionProperty("pickListAutomaticPrint","on")) {
			var showCanceledItems = hlp.findParamInSectionConfig("showCanceledItems","UserInterface");
			if(PosCheckSessionProperty("workingMode","cashier")) {
				showCanceledItems =	showCanceledItems+":1"
			}
			//first we give the change and just after that we print the receipt
			if(firstPickListReceipt == false && typeof(PosDispenseChangeJS) == 'function' && coinDispCalled == false)
			{
				PosDispenseChangeJS();
				coinDispCalled =true;
			}
			PosCreateReport("FULLCONSVIEW","reportPickList@reports.nps",flags,showCanceledItems);
			if(firstPickListReceipt == true && typeof(PosDispenseChangeJS) == 'function' && coinDispCalled == false)
			{
				PosDispenseChangeJS();
				coinDispCalled= true;
			}
		}
		//if we did not call the dispense procedure now is the moment
		if(typeof(PosDispenseChangeJS) == 'function' && coinDispCalled == false) {
			PosDispenseChangeJS();
		}
		
		PosGCActivationJS(flags);
		PosSetSessionProperty("activatedCOD","0","true")
		// Lindomar Araujo: 02/10/2007 - Changed to show the Basescreen after the HTML screen appears
		if( !PosCheckSessionProperty("POD","CSO")) {
			if(bumpBar == null || (bumpBar+"") == "" || closeTenderForGlobal == "true")
			{
				PosShowScreen(ctx.get("baseScreenId"));
			}
		}
		if(noAutoRecall || !PosDoAutoRecallJS()) {
			// Either no auto recall was received, or the drawer is opened or failed auto recall
			PosDoSkimWarning();
			// Correct end, returns true to stpo further execution
			return(true);
		}
	}
	// Incorrect end, returns false to continue further execution
	return(false);
}

/**PosDoStoreJS
 *
 * @brief - This BC store the sale in a tendering process
 * Return - rval - true if should stop execution
 */
function PosDoStoreJS()
{
	if(!PosDoStore()) {
		return(false);
	}
	PosSetSessionProperty("activatedCOD","0","true");
	var ctx=new SessionContext;
	PosShowScreen(ctx.get("baseScreenId"));
	
	if(PosCheckSessionProperty("pickListAutomaticPrint","on")) {
		var hlp = new BusinessObjectHelper;
		var showCanceledItems = hlp.findParamInSectionConfig("showCanceledItems","UserInterface");
		PosCreateReport("FULLCONSVIEW","reportPickList@reports.nps","NOPREVIEW",showCanceledItems+":1");
	}
	
	return(true);
}

/**PosDoTotalJS
 *
 * @brief - This BC totalizes a sale
 * Return - rval - true if allowed to continue
 */
function PosDoTotalJS(saleType,screenNumber,screenNumberStore,flags,choices)
{ 

	var hlp=new BusinessObjectHelper;	
	var familypackflag = hlp.findParamInSectionWide("FamilyPackDiscountActive","FamilyPack");
	
	if(PosNotATransactionInProgress(true)) {
		return(false);
	}
	if(!PosSetSaleType(saleType)) {
		return(false);
	}
	// Handle choices...
	if(!PosAutoChoice()) {
		return(false);
	}
	
	// Handle choices...
	if(PosSetOnTotalSmartReminder()) {
		return(false);
	}
	
	if(choices == null)
	{
		//try to take them from store-db
		if(storeDB_choices != "")
		{
			choices = storeDB_choices;
		}
	}
	
	
	if(choices != null) {
		var choiceArray=choices.split(",");
		if(choiceArray != null) {
			var i=0;
			for(;i < choiceArray.length; i++) {
				var choice_screen=choiceArray[i].split("|");
				if(choice_screen != null) {
					if(!PosCheckChoice(choice_screen[0],choice_screen[1],true,"MSG_BC_SALE_INCOMPLETE")) {
						return(false);
					}
				}
			}
		}
	}
	// Calls FVM before starting tender process NB: if recalled sales will need also FVM this call should be in event onTotal instead of here!
	PosSolveChoiceByTaxRange();
	
	//if family pack voucher for NL is active then we must display the voucher option if any
	/* for the moment they do not want it
	if(! PosCheckTransactionKind(2) && !PosCheckTransactionKind(1))
	{
		if(familyPackVoucherActive == null)
		{
			familyPackVoucherActive =hlp.findParamInSectionWide("Active","FamilyPack_Voucher")=="true";
		} 
		if(familyPackVoucherActive == true)
		{
			familyVoucher_AvailableVouchers();
		}
	}
	*/
	//end family pack voucher
	
	// Now totals
	if(!PosDoTotal()) {
		return(false);
	}
	//call the family pack logic 
	if( (familypackflag =="1") &&  PosCheckSessionProperty("familypackForDTSTORE", "1")==false)
	{ //familypackForDTSTORE is 1 only if we press DTSTORE and in that case we must not have a discount transaction or if we have a second discount
		familyPackDiscount();
	}
	var tenderType=-1;
	if(PosCheckTransactionKind(1)) {
		// Refund
		if(PosCheckRefund()) {
			var ok=true;
			var storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"DialogSettings\").Parameter.(@name==\"refundDialogSelection\").@value";
			var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"DialogSettings\").Parameter.(@name==\"refundDialogSelection\").@value";
			var refundSelection = getConfigValue(storedbPath , posdbPath);
	
			if(Number(refundSelection) == 2) //NL just cash refund 
			{
                //23.05.2011 OI the value needs to be set because we don't open a dialog here.
                //ok="0";
				PosSetSessionProperty("SelectedButtonValue","0",true);
           	}
			else if(Number(refundSelection) == 1)
			{
				var boHelper		= new BusinessObjectHelper;
				ok=PosItemSelection("cash.png|cancel.png","0|-1",API.getLocalMsg("MSG_REFUND_CHOOSE"),API.getLocalMsg("MSG_REFUND_CHOOSE_DESC"));
			}
			else 
			{
				if(PosIsCashlessLoadedJS()) {
					// Replaced by Chris Appleton, 31st July 2008, SOTEC ECash Changes
					 // ok=PosItemSelection("cashless.png|cash.png|cancel.png","10|0|-1","Choose","Choose: CASHLESS, CASH or CANCEL");
					  ok=PosItemSelection("cashless.png|cash.png|cancel.png","21|0|-1","Choose","Choose: CASHLESS, CASH or CANCEL");
				}
				else
				{
					var boHelper		= new BusinessObjectHelper;
					ok=PosItemSelection("cash.png|cancel.png","0|-1",API.getLocalMsg("MSG_REFUND_CHOOSE"),API.getLocalMsg("MSG_REFUND_CHOOSE_DESC"));
				}
			}
			if(ok) {
				var ctx = new SessionContext;
				tenderType=Number(ctx.get("SelectedButtonValue"));
				if(0 == tenderType) {
					if(!PosCheckCash()) {
						tenderType=-1;
					}
				}
			}
		}
	}
	else {
		if(PosCheckTransactionKind(2)) {
			// Waste
			tenderType=0;
		}
		else {
			// Normal Sale
					
			if(PosCheckSessionProperty("workingMode","orderTaker") || (PosCheckSessionProperty("workingMode","both") && PosCheckSessionProperty("saleRecalled","false"))) {
				PosShowScreen(screenNumberStore);
			}
			else {
				PosShowScreen(screenNumber);
			}
			return(true);
		}
	}
	if((tenderType < 0) || !PosDoTender(tenderType,-1)) {
		PosDoBackFromTotal();
		return(false);
	}
	return(PosDoEndOfSaleJS(true,flags,0));	
}

/**PosRemotePickListJS
 *
 * @brief - This BC prints a remote pickList
 * Return - rval - true
 */
function PosRemotePickListJS(view) {

	var hlp=new BusinessObjectHelper;	
	var ctx=new SessionContext;
	ctx.set(KEY_REMVIEW,view,true);
	var showCanceledItems = hlp.findParamInSectionConfig("showCanceledItems","UserInterface");
	PosCreateReport("FULLCONSVIEW","reportPickList@reports.nps","REMOTE",showCanceledItems+":1");
	ctx.remove(KEY_REMVIEW,true);
	return(true);
}

/**RepPreviewFilterJS
 *
 * @brief - This BC shows/changes the report preview filter used in reports
 * Return - rval - true if allowed to continue
 */
function RepPreviewFilterJS(change)
{
const reportType=["default","on"];
const properties=[
	"bitmap|printPreviewOff.png,bitmapdn|printPreviewOff.png,title|print\npreview\noff",
	"bitmap|printPreviewOn.png,bitmapdn|printPreviewOn.png,title|print\npreview\non"
];
	var i=0;
	// Loops up to length because the very first time reportPOD might not be set!
	for(i=0;i < reportType.length;i++) {
		if(PosCheckParameter("Report","reportPreviewOverride",reportType[i])) {
			break;
		}
	}
	if(i >= reportType.length) {
		i=("true"==change) ? 1 : 0;
	} else {
		if("true"==change) {	// Next
			++i;
		}
		if(i >= reportType.length) {
			i=0;
		}
	}
	// either reportPOD was not set or changing from the last to the first...
	PosChangeButtonProperties(0,properties[i]);
	if("true"==change) {	// Next
		PosSetParameter("Report","reportPreviewOverride",reportType[i]);
	}
	return(true);
}

/**PODFilterJS
 *
 * @brief - This BC shows/changes the POD Filter used in reports
 * Return - rval - true if allowed to continue
 */
function PODFilterJS(change)
{
const reportType=["ALL","FC","DT","WT"];
const reportButton=["bitmap|postypeall.png","bitmap|postypefc.png","bitmap|postypedt.png","bitmap|postypewt.png"];

	var i=0;
	// Loops up to length because the very first time reportPOD might not be set!
	for(;i < reportType.length;i++) {
		if(PosCheckSessionProperty("reportPOD",reportType[i])) {
			break;
		}
	}
	if("true"==change) { // Next
		i++;
	}
	if(i >=reportType.length) {
		i=0;
	}
	// either reportPOD was not set or changing from the last to the first...
	PosChangeButtonProperties(0,reportButton[i]);
	if("true"==change) { // Next
		PosSetReportScope("CONSOLIDATED",reportType[i]);
	}
	return(true);
}

/**PosDoOperatorLoginJS
 *
 * @brief - This BC performs the loggin for an operator
 * Return - rval - true if allowed to continue
 */
function PosDoOperatorLoginJS(tp,flags)
{
	//fiscal printer test. Not alow to use ot/cashier or cashier on registers that have no fiscal printer
	var hlp = new BusinessObjectHelper;
	runGetConfig_Eurecs =true; //enable again to run the cash report to get the current configuration required for e-cash transactions (reset in onLogoutFInialise is nto working because is a CSL function)
	if(!PosDoOperatorLogin()) {
		return(false);
	}
		
	if(PosCheckParameter("TCLExtension","telequipt","true") ==true && (PosCheckSessionProperty("CoinDispenserState","true") || !PosCheckSessionProperty("CoinDispenserState","false")) ) //coin dispenser present and active
	{
		//OI 26.01.2010 add for 6.1.17
		// Inform the Coin Dispenser Initial Amount
		PosTransfer(15,"0",-1,"","Telequip");
		//PosTransfer(12,0,"",-1);
	}
	PosCreateReport("CASH","reportOperatorLogin@reports.nps",flags);
	var ctx=new SessionContext;
	PosShowScreen(ctx.get("baseScreenId"));

	return(true);
}

/**PosReportSOSJS
 *
 * @brief - This BC creates an SOS report
 * Return - rval - true if allowed to continue
 */
function PosReportSOSJS(dataTypes, flags, selected) {

	var ctx=new SessionContext;
	var hlp = new BusinessObjectHelper;
	var report="";
	var pod="";
	var typesImageNamesList = "";
	var typesIDList = new Array();
	var optionsIndexList = "";
	var typesReportNamesList = new Array();
	var typesClassesList = new Array();
	var typesTitlesList = new Array();
	var sos_reports_typesids = hlp.findParamInSectionWide("typesids", "SOS_Reports");	
	var sos_reports_typesimages = hlp.findParamInSectionWide("typesimages", "SOS_Reports");	
	var sos_reports_typesreports = hlp.findParamInSectionWide("typesreports", "SOS_Reports");	
	var sos_reports_typesclasses = hlp.findParamInSectionWide("typesclasses", "SOS_Reports");	

	if (sos_reports_typesids == null || sos_reports_typesids.length == 0) {
		PosShowMessage("MSG_SOSREPORT_TYPES_NOTDEFINED");
		return (false);
	}

	if (sos_reports_typesclasses == null || sos_reports_typesclasses.length == 0) {
		PosShowMessage("MSG_SOSREPORT_CLASSES_NOTDEFINED");
		return (false);
	}

	if (sos_reports_typesimages == null || sos_reports_typesimages.length == 0) {
		PosShowMessage("MSG_SOSREPORT_IMAGES_NOTDEFINED");
		return (false);
	}

	if (sos_reports_typesreports == null || sos_reports_typesreports.length == 0) {
		PosShowMessage("MSG_SOSREPORT_REPORTS_NOTDEFINED");
		return (false);
	}
	
	// Mounts a IDs list.
	var auxList = sos_reports_typesids.split(';');
	var counter = 0;
	typesIDList = new Array(auxList.length);
	for (;counter < auxList.length; counter++) {
		typesIDList[counter] = trim(auxList[counter]);
		optionsIndexList = optionsIndexList + counter + "|";
	}
	// Add cancel button
	optionsIndexList = optionsIndexList + counter;

	// Mounts a classes list.
	auxList = sos_reports_typesclasses.split(';');
	if (auxList.length != typesIDList.length) {
		PosShowMessage("MSG_SOSREPORT_CLASSES_WRONGSIZE");
		return (false);
	}	
	counter = 0;
	typesClassesList = new Array(auxList.length);
	for (;counter < auxList.length; counter++) {
		typesClassesList[counter] = trim(auxList[counter]);
	}
	
	// Mounts a images names list
	auxList = sos_reports_typesimages.split(';');
	if (auxList.length != typesIDList.length) {
		PosShowMessage("MSG_SOSREPORT_IMAGES_WRONGSIZE");
		return (false);
	}	
	counter = 0;
	var elements = new Array(0);
	typesTitlesList = new Array(auxList.length);
	for (;counter < auxList.length; counter++) {
	    elements = trim(auxList[counter]).split("|");
		
	    if (elements.length > 1 && trim(elements[1]).length > 0 && trim(elements[1]).toLowerCase().indexOf(".png") > 0) {
		    // Gets image name
			typesImageNamesList = typesImageNamesList + trim(elements[1]);
			
		} else {
		    // Gets description
			typesImageNamesList = typesImageNamesList + trim(elements[0]);
		}
		// Gets description to be used as report title.
		typesTitlesList[counter] = trim(elements[0]);
		
		typesImageNamesList = typesImageNamesList + "|";
	}
	// Add cancel button
	typesImageNamesList = typesImageNamesList + "cancel.png";
		
	// Mounts a Reports list.
	auxList = sos_reports_typesreports.split(';');
	if (auxList.length != typesIDList.length) {
		PosShowMessage("MSG_SOSREPORT_REPORTS_WRONGSIZE");
		return (false);
	}	
	counter = 0;
	typesReportNamesList = new Array(auxList.length);
	for (;counter < auxList.length; counter++) {
		typesReportNamesList[counter] = trim(auxList[counter]);
	}
	
	// Mounts descriptions/titles list
	counter = 0;
	elements = new Array(0);	
	for (; counter < typesClassesList.length; counter++) {
	    elements = trim(typesClassesList[counter]).split("|");
		
		if (elements.length > 0) {
			typesTitlesList[counter] = typesTitlesList[counter] + " (Class ";
			for (var index = 0; index < elements.length; index++) {
				typesTitlesList[counter] = typesTitlesList[counter] + trim(elements[index]) + ",";
			}
			typesTitlesList[counter] = typesTitlesList[counter].substring(0, typesTitlesList[counter].length - 1); // Remove last separator
			typesTitlesList[counter] = typesTitlesList[counter] + ")";
			
		} else {
			typesTitlesList[counter] = "";
		}
	}	
		
	selected = String((selected == null) ? "undefined" : selected);
	if (selected == 'undefined' || (Number(selected) < 0 && Number(selected) >= optionsIndexList.length)) {
	    selected = '-1';
	}
	
	var selectedIndex = 0;
	if (Number(selected) == -1) {
		if (!PosItemSelection(typesImageNamesList, optionsIndexList, "MSG_WFL_SELECT", "MSG_WFL_SEL_REPORT")) {
			return (false);
		}
			
        selectedIndex = Number(ctx.get("SelectedButtonValue"));
	} else {
		selectedIndex = Number(selected);
	}
	
	if (selectedIndex == optionsIndexList[optionsIndexList.length - 1]) {
	    // Cancel
		return (true);
	}
	report = typesReportNamesList[selectedIndex];
	pod    = typesIDList[selectedIndex];
	
	// Put title in memory to be used when flow was passed to report.
	ctx.set('sosRptTitle', typesTitlesList[selectedIndex]);
	ctx.set('sosRptPOD', pod);
	
	//PosShowMessage("dataTypes:" + dataTypes + "\nreport:" + report + "\nflags:" + flags + "\npod:" + pod + "\nselectedIndex:" + selectedIndex);;
	PosCreateReport(dataTypes,report,flags,"","",pod);
	return(true);
}

/**CheckCDrawerOpModeJS
 *
 * @brief - This BC set a button property according to cash drawer oper mode 
 * Return - rval - true if allowed to continue
 */
function CashDrawerOpModeJS(buttonNumber,prop,prop1,prop2) {

	if(PosIsCashDrawerForced()) {
		PosChangeButtonProperties(buttonNumber,prop+"|"+prop1,prop+"dn|"+prop2);
	}
	else {
		PosChangeButtonProperties(buttonNumber,prop+"|"+prop2,prop+"dn|"+prop1);
	}		
}	

/**HideMeIfPreviewByTypeJS
 *
 * @brief - This BC hhides a button (according to a type) 
 * btnType: 0 -> RecallByPreview button on a regular screen
 * 			1 -> Simple Recall button on a regular screen
 * 			2 -> RecallByPreview button on a tender screen
 * 			3 -> Simple Recall button on a tender screen
 * Return - rval - true 
 */

function HideMeIfPreviewByTypeJS(btnType) {

	var hide=false;
	
	
	if( !PosCheckSessionProperty("POD","DRIVE_THRU") || 
		PosCheckSessionProperty("workingMode","orderTaker")) {
		hide=true;
	}
	else {
		if(PosCheckParameter("UserInterface","DDTsupport","true")) {
			if((Number(btnType)%2) == 1) {
				// Simple Recall cannot have DDTsupport true
				hide=true;		
			}
		}
		else {
			if((Number(btnType)%2) == 0) {
				// Recall by preview cannot have DDTsupport false
				hide=true;		
			}
		}
		if(!hide && (Number(btnType) > 1) && !PosCheckSessionProperty("saleRecalled","true")) {
			// Tender Screen
			hide=true;		
		}
	}
	if(hide) {
		PosChangeButtonProperties(0,"visible|false");
	}
	else {
		PosChangeButtonProperties(0,"visible|true");
	}	
	return(true);
}
/**ShowButtonRecallByListJS
 *
 * @brief - This BC hhides a button (according to a type) 
 * Return - rval - true 
 */

function ShowButtonRecallByListJS(podType,workingMode, btnType) {

	var podDT=false;
	var podWT=false;
	var podFC=false;
	
	var podTypes=new Array();
	var podStrArray=podType.split("|");
	if ((podStrArray == null) || (podStrArray.length <= 0)) {
		return(null);
	}
	
	for(var i=0; i < podStrArray.length; ++i) {
		if ("DRIVE_THRU"==podStrArray[i]) {
			podDT = PosCheckSessionProperty("POD","DRIVE_THRU") && PosCheckSessionProperty("workingMode",workingMode);
		}
		if ("WALK_THRU"==podStrArray[i]) {
			podWT = PosCheckSessionProperty("POD","WALK_THRU") && PosCheckSessionProperty("workingMode",workingMode);
		}
		if ("FRONT_COUNTER"==podStrArray[i]) {
			podFC = PosCheckSessionProperty("POD","FRONT_COUNTER");
		}
	}
	
	if (podDT || podWT || podFC) {
		PosChangeButtonProperties(btnType,"visible|true");
	}
	else {
		PosChangeButtonProperties(btnType,"visible|false");
	}	
	return(true);
}

/**PosDoOperatorLogoutJS
 *
 * @brief - Do an Operator Logout
 * Return - rval - true
 */
function PosDoOperatorLogoutJS()
{
	if(!PosCheckCashDrawer())
	{
		PosShowMessage("MSG_BC_DRAWEROPENED");
		return false;
	}
	var	bPodDT					= PosCheckSessionProperty("POD","DRIVE_THRU");
	var	bOperationMode			= PosCheckParameter("OperationMode","checkOpenOrdersOnDrawerChange","true");
	var	bQueryStoredNO			= true; // PosQueryStoredNumberOrders();
	//var	bWorkingModeOT 		= PosCheckSessionProperty("workingMode","orderTaker");
	var	bWorkingModeCS			= PosCheckSessionProperty("workingMode","cashier");
	var	bWorkingModeBoth		= PosCheckSessionProperty("workingMode","both");
	var 	bOpenOrderValidation 	= (/*bPodDT &&*/(bWorkingModeCS || bWorkingModeBoth)  && bOperationMode && bQueryStoredNO);
	var	bConfirmationNO = false;
	
	/*
	if(bOpenOrderValidation)
	{
		bConfirmationNO = PosShowConfirmationMessage("MSG_BC_OPENORDER","MSG_YES","MSG_NO");
	}
	if((!bOpenOrderValidation) || (bOpenOrderValidation && bConfirmationNO))
	{
		if(PosDoOperatorLogout())
		{
			PosCreateReport("ALL","reportOperatorLogout@reports.nps","SAVE|NOPREVIEW");
		}
	}
	*/
	
	var ret = PosDoOperatorLogout(false);
	if(ret ==true)
	{
		PosCreateReport("ALL","reportOperatorLogout@reports.nps","SAVE|NOPREVIEW");
	}
	
	return ret;
}

/**PosDoOperatorLogout
 *
 * @brief - This BC calls PosDoOperatorLogout_CSL and, if defined, onLogoutFinalize
 * @param remote - String - Optional, "true" to indicate a remote logout (default:"false")
 * @hook <i>onLogoutFinalize()</i> -  invoked after PosDoOperatorLogout_CSL
 */
function PosDoOperatorLogout(remote) {
	var ret = PosDoOperatorLogout_CSL(remote);
	if(typeof(onLogoutFinalize) == "function") {
		ret = onLogoutFinalize();
	}
	return ret;
}

/**ShowButtonToPOD
 *
 * @brief - This BC hhides a button (according to a type) 
 * Return - rval - true 
 */
function ShowButtonToPOD(btnType, bitmapDT, bitmapdnDT, bitmapWT, bitmapdnWT, bitmapFC, bitmapdnFC) {

	var podDT = PosCheckSessionProperty("POD","DRIVE_THRU");
	var podWT = PosCheckSessionProperty("POD","WALK_THRU");
	var podFC = PosCheckSessionProperty("POD","FRONT_COUNTER");
	
	var button 	 ="bitmap|";
	var buttondn ="bitmapdn|";
	if (podDT) {
		if (bitmapDT!=null) {
			button +=bitmapDT;
			buttondn +=bitmapdnDT;
			PosChangeButtonProperties(btnType,button);
			PosChangeButtonProperties(btnType,buttondn);
		}
		else {
			PosChangeButtonProperties(btnType,"visible|false");
		}
	}
	else {
		if (podWT) {
			if (bitmapWT!=null) {		
				button +=bitmapWT;
				buttondn +=bitmapdnWT;
				PosChangeButtonProperties(btnType,button);
				PosChangeButtonProperties(btnType,buttondn);
			}
			else {
				PosChangeButtonProperties(btnType,"visible|false");
			}
		}
		else {
			if (bitmapFC!=null) {			
				button +=bitmapFC;
				buttondn +=bitmapdnFC;
				PosChangeButtonProperties(btnType,button);
				PosChangeButtonProperties(btnType,buttondn);
			}
			else {
				PosChangeButtonProperties(btnType,"visible|false");
			}
		}
	}	

	return(true);
}

/**PosCreateReceiptJS
 *
 * @brief - This BC perform PosCreateReport with appropriate type of receipt
 * Return - true if ok
 */
function PosCreateReceiptJS(kioskDup,szDataType,szScript,szFlags,szCustParams,szPODtype,szServiceList,szPOSList) {

	var hlp = new BusinessObjectHelper;
	var vatNumber = hlp.findParamInSectionWide("VatNumber","VAT");
	if(undefined == szCustParams) {
		szCustParams="";
	}
	if(kioskDup > 0 || PosCheckParameter("Report","kioskReceipt","true")) {
		// Kiosk receipt
		PosCreateReport(szDataType,"receiptkiosk@reports.nps",szFlags,szCustParams+":0:"+vatNumber,szPODtype,szServiceList,szPOSList);
		// PosCreateReport(szDataType,"receiptkiosk@reports.nps",szFlags+"|ALIAS",szCustParams+":1:"+vatNumber,"EXTRAREC",szServiceList,szPOSList);
	}
	else {
		// Normal receipt
		szCustParams = vatNumber;
		PosCreateReport(szDataType,"receipt@reports.nps",szFlags,szCustParams,szPODtype,szServiceList,szPOSList);
	}
	// DES-163 Changed by Lindomar Araujo in 29/02/2008 in Germany
	if(PosCheckParameter("UserInterface","PrintLocalSaladClaim","true")) {
		PosCreateReport(szDataType,"reportSaladWrapClaim@reports.nps",szFlags,szCustParams,szPODtype,szServiceList,szPOSList);
	}
	if(PosCheckParameter("UserInterface","PrintRemoteSaladClaim","true")) {
		PosCreateReport(szDataType,"reportSaladWrapClaim@reports.nps",szFlags+"|ALIAS",szCustParams,"SALADREC",szServiceList,szPOSList);
	}
}

/**PickListOnOffJS
 *
 * @brief - This BC perform the configuration od Pick List receipt
 * Return - true if ok
 */
function PickListOnOffJS(change,onClick)
{
const PickListMode=["on","off"];
const PickListModeButton=["bitmap|pickliston.png","bitmap|picklistoff.png"];

	if(onClick=="true") {
		var i=0;
		// Loops up to length because the very first time reportPOD might not be set!
		for(;i < PickListMode.length;i++) {
			if(PosCheckSessionProperty("pickListAutomaticPrint",PickListMode[i])) {
				break;
			}
		}
		if("on"==change) { // Next
			i++;
		}
		if(i >=PickListMode.length) {
			i=0;
		}
		// either reportPOD was not set or changing from the last to the first...
		PosChangeButtonProperties(0,PickListModeButton[i]);
		if("on"==change) { // Next
			PosSetSessionProperty("pickListAutomaticPrint",PickListMode[i],"false");
		}
	}
	else {
		var i=0;
		// Loops up to length because the very first time reportPOD might not be set!
		for(;i < PickListMode.length;i++) {
			if(PosCheckSessionProperty("pickListAutomaticPrint",PickListMode[i])) {
				break;
			}
		}
		PosChangeButtonProperties(0,PickListModeButton[i]);
	}

	return(true);
}

/**PosDetachJS
 *
 * @brief - This BC performs a local or remote detach
 * Return - rval - true if allowed to continue
 */
function PosDetachJS(remote)
{
	var ctx=new SessionContext;
	if("false" == remote) {
		if(PosCheckState("POS_OpLogged")) {
			PosShowMessage("MSG_BC_LOGOUTOP");
			return(false);
		}
		if(!PosShowConfirmationMessage("MSG_BC_CONFDETACH","MSG_YES","MSG_NO")) {
			return(false);
		}
		if(!PosRemoteDetach()) {
			return(false);
		}
		var hlp=new BusinessObjectHelper;
		var cmdLine=hlp.findParamInSectionConfig("stageCmd","PosType");
		if(!PosRunOSCommand(cmdLine+" 2")) {
			return(false);
		}
		if(!PosShutdown("92", "remote", "false")) {
			return(false);
		}
	} else {
		if(!PosChooseRemotePOS("1","MSG_BC_REMOTEDETACH","MSG_BC_CONFREMDETACH")) {
			return(false);
		}
		if(!PosRemoteDetach(ctx.get("SELECTED_REMPOS"))) {
			return(false);
		}
	}
	return(true);
}

/**PickListOnOffJS
 *
 * @brief - This BC perform the configuration od Pick List receipt
 * Return - true if ok
 */
function PrintPickListJS(flag)
{
	var hlp = new BusinessObjectHelper;
	var currentView = hlp.getCurrentView();
	if(currentView != null) {	
		var ctx=new SessionContext;
		var view = new XML(currentView);	
		ctx.set(KEY_REMVIEW,view.toString(),true);
		var showCanceledItems=hlp.findParamInSectionConfig("showCanceledItems","UserInterface");
		PosCreateReport("FULLCONSVIEW","reportPickList@reports.nps",flag+"|REMOTE",showCanceledItems+":1");		
	}
	return(true);
}

/**POSVerifyRunnerBoxJS
 *
 * @brief - This function implements the BC,Business Component: <b>POSVerifyRunnerBoxJS</b>\n
 * Return - rval - True for successful execution or False for failure.
 */
function POSVerifyRunnerBoxJS(prop1,prop2) {

	if(!PosCheckParameter("OperationMode","runnerBoxActive","true")) {
		return(false);
	}
	var prop=(PosCheckRunnerBox("on"))?prop2:prop1;
	PosChangeButtonProperties(0,prop);
	return(true);
}

/**PosScreenTimeOutJS
 *
 * @brief - This BC handles a screen timeout event
 * managerScrRange: manager screen range
 * screenRange: CSO screen range
 * grillScreen: CSO grill screen
 * timeoutScreen: CSO timeoutScreen screen
 * Return - true
 */
function PosScreenTimeOutJS(managerScrRange,screenRange,grillScreen,sound) {
	var ctx=new SessionContext;
	if(!PosCheckCurrentScreen(managerScrRange)) {
		// Not in a manager range
		if(!PosCheckSessionProperty("POD","CSO") || !PosCheckCurrentScreen(screenRange)) {
			// Not CSO or CSO in a regular screen
			PosBackToPreviousScreen();
			return(true);
		}
		if(PosCheckCurrentScreen(ctx.get("baseScreenId"))) {
			PosReloadCurrentScreen();
			return(true);
		}
		PosPlaySound(sound);
		// Ask customer if should extend time
		if(PosShowConfirmationMessage("TIMEOUT_SCREEN","MSG_YES","MSG_NO")) {
			PosReloadCurrentScreen();
			PosProtectQuantity();
			return(true);
		}
		if(PosIsInSaleMode("false") && !PosNotATransactionInProgress("true")) {
			if(PosCheckCurrentScreen(grillScreen)) {
				PosDoGrillEnd("2");
				PosDoQuantum("-1");
			}
			if(PosCheckSessionProperty("TenderAccepted","true")) {
				return(PosDoStoreDuetJS("2","21"));
			}
			else {
				return(PosDoCancelOrderDuetJS());
			}
		}
	}
	PosShowScreen(ctx.get("baseScreenId"));
	return(true);
}

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/* functions from the old businessComponents.nps avaible untill nps script version for pilot version 6.1.4  */
/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/** PosDoSkipCarJS
 *
 * @brief - This function implements the BC,Business Component: <b>PosDoSkipCarJS</b>\n
 * This BC put skip Car!\n
 * In a workflow sequence it is called:<b>PosDoSkipCarJS</b>\n
 * In java script it should be called:<b>PosDoSkipCarJS</b>\n
 * Return - rval - true if possible
 */
function PosDoSkipCarJS()
{
	return(PosDoSkipCar_CSL());
}

/**PosDoTenderJS
 *
 * @brief - This BC tenders a sale
 * Return - rval - true if allowed to continue
 */
function PosDoTenderJS(tenderID,amount,flags)
{
	// Clears info area
	PosDisplayText("",1);
	//API.DbgMessageBox(tenderID+ " "+amount+ " "+flags);
	//<Section name="CheckTenderWithKeepExcess"> <Parameter name="CheckActive" value="1"/> </Section>
	
	var bEndOfSale=PosDoTender(tenderID,amount);
	var hlp = new BusinessObjectHelper;
	var viewXML = new XML(hlp.getCurrentView());
	if(viewXML == null)
	{
		viewXML = new XML(hlp.getLastView());
	}
			
	//API.dbg("tender mihai " + viewXML);
	PosHandleCalculatorButton("clear");
	if(bEndOfSale) {
		//test if there is an excess
		var storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"CheckTenderWithKeepExcess\").Parameter.(@name==\"CheckActive\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"CheckTenderWithKeepExcess\").Parameter.(@name==\"CheckActive\").@value";
		var askExcess = getConfigValue(storedbPath , posdbPath);
		if(askExcess == "1")
		{	
			if(PosCheckTenderExcess(tenderID)) //tender that keep excess
			{
				if(!PosShowConfirmationMessage("MSG_BC_EXCESS","MSG_YES","MSG_NO")) //we do not want to continue
				{
					//undo the paying
					PosDoBackFromTotal();
					if(Country =="DE")
					{
						PosDoTotalJS("1",TENDER_SCREEN_NBR_DE, STORE_SCREEN_NBR_DE, "NOPREVIEW|SAVE");
					}
					else
					{
						PosDoTotalJS("1",TENDER_SCREEN_NBR, STORE_SCREEN_NBR, "NOPREVIEW|SAVE");
					}
					return false;
				}
			}
		}
	
		// Last tender -> ends sale
		if(typeof(PosDoEndOfSaleJS) == "function") {
			var noAutoRecall=!(PosIsCashDrawerForced()||!PosCheckSessionProperty("IsCDrawerSetToOpen","true"))
			PosDoEndOfSaleJS(noAutoRecall,flags,0);
		}
		else {
			PosDoEndOfSale(true);
		}
	}
	return(true);
}

/**PosDoDiscountJS
 *
 * @brief - This BC gives a discount in a sale
 * Return - rval - true if allowed to continue
 */
function PosDoDiscountJS(discountID,discountType,discountInputMode,discountValue,description,flags)
{
	// (db) min amount after employee meal discount
	var storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EmployeeMealDiscount\").Parameter.(@name==\"EmployeeMealDiscountActive\").@value";
	var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EmployeeMealDiscount\").Parameter.(@name==\"EmployeeMealDiscountActive\").@value";
	var employeeMealDiscountActive = getConfigValue(storedbPath , posdbPath);
	if(employeeMealDiscountActive == "1" && discountType == 2) {
		var hlp = new BusinessObjectHelper;
		
		
		var xmlCurrentView = new XML(hlp.getCurrentView());
		var currentSaleSum = Number(xmlCurrentView.@totalAmount);
		if(employeeMealDiscountActive == "1") {
			// min pay
			var storedbPath = "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EmployeeMealDiscount\").Parameter.(@name==\"MinEmpDiscountPayAmount\").@value";
			var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EmployeeMealDiscount\").Parameter.(@name==\"MinEmpDiscountPayAmount\").@value";
			var minEmpDiscountPayAmount = getConfigValue(storedbPath , posdbPath);
			if(minEmpDiscountPayAmount == null || (minEmpDiscountPayAmount + "") == "") {
				minEmpDiscountPayAmount = 2.05
			}
			// discount rate
			var empDiscRate = Number(xmlStoreDB.StoreDB.DiscountTables.DiscountTable.(DiscountId == discountID).DiscountRate);
			if(currentSaleSum * (1 - empDiscRate / 100) < minEmpDiscountPayAmount) {
				// employee would pay too little money, this is forbidden
				discountInputMode = 1;
				discValue = Number(currentSaleSum - minEmpDiscountPayAmount);
				if(discValue <= 0) {
					// treat as regular sale
					return(true);
				}
				discountValue = API.formatNumber(discValue, "##0.00", 6);
			}	
		}
	}
	if(PosDoDiscount(discountID,discountType,discountInputMode,discountValue,description)) {
		// Ends sale
		if(typeof(PosDoEndOfSaleJS) == "function") {
			PosDoEndOfSaleJS(false,flags,0);
		}
		else {
			PosDoEndOfSale(true);
		}
	}
	PosHandleCalculatorButton("clear");
	return(true);
}

/** 
 * @brief This function implements the BC,Business Component: <b>PosDoDiscount</b>.
 *
 * Persistence:<b>Not Persisted</b>\n
 * This BC applies a discount to the sale according to the received parameters.
 * An error message is displayed if the current transaction is not a sale.
 *
 * @param nDiscountId - string - (numeric value) discount id as configured in store-db
 * @param nDiscountType - string - type of discount: 1-normal (default)\n 
 *													 2-crew meal\n 
 *													 3-manager meal
 * @param nInputMode - string - optional - type of input: 0-no input (default)\n
														  1-amount\n
														  2-rate\n
														  3-operator inputs an amount\n
														  4-operator inputs a rate
 * @param value - string - optional - it depends of input mode. If input mode is 1 it's a amount. If input mode is 2 it's a rate. Otherwise it's ignored.
 * @param description - string - optional - discount discription.
 * @success Discount granted successfully.
 * @failure	<i>Not authorized</i> - This operation needs manager authorization.\n
 * @failure	<i>Not valid discount</i> - The discount id is unknown.\n
 * @failure	<i>Amount exceeded</i> - Maximum discount amount allowed was exceeded.\n
 * @failure	<i>Rate exceeded</i> - Maximum discount rate allowed was exceeded.\n
 * @failure	<i>Unable to do tender</i> - The income must be equal or greater than the order value.\n
 * @failure <i>Not in sale operation</i> - The operator is allowed to apply a discount only if the operatation is a sale.\n
 * @hook <i>onDiscount()</i> - called when this BC starts.
 * @hook <i>onCanDiscount()</i> - called by PosDoDiscount_CSL after the discount is appllied. If this event returns false, the discount is cancelled.
 * @remarks
 *
 * Property Messages:\n
 *	 MSG_BC_DISCNOTALLOW: Show a message that the discount is not allowed.\n
 *   MSG_BC_DISCOUNT_AMOUNT: Show a message that discount amount is invalid.\n
 *   MSG_BC_DISCOUNT_RATE: Show a message that discount rate is invalid.\n
 *   MSG_BC_INVDISCOUNT: Show a message that the discount id is unkowning.\n
 *   MSG_BC_MAX_DISCOUNT: Show a message with maximum discount amount allowed.\n
 *   MSG_BC_MAX_RATE: Show a message with maximum discount rate allowed.\n
 *   MSG_BC_DISCNOTALLOW: Show a message that the operator is allowed to apply a discount only if the operation is a sale.\n
 * 	 MSG_BC_RETPAYMENT: Show a message when an error occured while computing discount.\n
 *	 
 */
function PosDoDiscount(nDiscountId, nType, nInputMode, value, description) {
	var hlp = new BusinessObjectHelper;
	var result = false;
	if(!onDiscount(nDiscountId,nType)) {
		API.SLog("LOGLEVL_DEBUG", "[PosDoDiscount] onDiscount returned false");
		return false;
	}
	
	if(undefined == nDiscountId) {
		PosShowMessage("MSG_BC_INVDISCOUNT");
	}
	//Execute
	switch (nInputMode) {
		default:
			API.SLog("LOGLEVL_DEBUG","PosDoDiscount called with invalid Input Mode: "+nInputMode);
			nInputMode = "0";
		case "0":
		case "1":
		case "2":
			result = PosDoDiscount_CSL(nDiscountId, nType, nInputMode, value, description);
			break;
		case "3":
			cPosGetMaxAmount();
			var maxAmount = getResult("cPosGetMaxAmount");
			message = hlp.getSysMessage("MSG_BC_DISCOUNT_AMOUNT", maxAmount);
			var currencySymbol = rootStoreDB.StoreDB.StoreProfile.Localization.CurrencySymbol;
			value = PosShowCalculator(message,currencySymbol,0,2);
			result = PosDoDiscount_CSL(nDiscountId, nType, nInputMode, value, description);
			break;	
		case "4":
			value = PosShowCalculator("MSG_BC_DISCOUNT_RATE","",5,2)/100;	// 10^(number of decimal places)
			result = PosDoDiscount_CSL(nDiscountId, nType, nInputMode, value, description);
			break;
	}
	//Handle results
	if (!result) {
		var messageBC = null;
		switch (nInputMode) {
			case "0": //Discount by table
				messageBC = getLastFail("cPosAddDiscountTable");
				break;
			case "1": //Discount by amount
			case "3":
				messageBC = getLastFail("cPosAddDiscountAmount");
				break;
			case "2": //Discount by rate
			case "4":
				messageBC = getLastFail("cPosAddDiscountRate");
				break;
			default:
				messageBC = null;
				break;
		}
		if(messageBC != null) {
			PosShowMessage(messageBC);
		}
	}	
	PosRefreshSalePanel();	
	return result;
}
/**PosChangeTaxModeJS
 *
 * @brief - This BC gives a discount in a sale
 * Return - rval - true if allowed to continue
 */
function PosChangeTaxModeJS(mode,flags)
{
	return(PosChangeTaxMode_CSL(mode,flags));
}


/**StartSpecialTrxJS
 *
 * @brief - This BC starts a special transaction (waste,refund)
 * Return - rval - true if allowed to continue
 */
function StartSpecialTrxJS(level,singleSignOn,kind,message,destination)
{
	return(StartSpecialTrx_CSL(level,singleSignOn,kind,message,destination));
}

/**HideButtonIfMatchPODJS
 *
 * @brief - This BC hhides a button (according to a type) 
 * Return - rval - true 
 */

function HideButtonIfMatchPODJS(podType,btnType) {
	return(HideButtonIfMatchPOD_CSL(podType,btnType));
}

/**PosChangePasswordJS
 *
 * @brief - This BC changes/resets an user password 
 * changeType: "CHANGE","RESET","RESETALL"
 * Return - true if changed, false otherwise
 */
function PosChangeUserPasswordJS(changeType) {
	return(PosChangeUserPassword_CSL(changeType));
}

/**PosTimePunchJS
 *
 * @brief - This BC set a time punch for a user 
 * Return - true if changed, false otherwise
 */
function PosTimePunchJS() {
	return(PosTimePunch_CSL());
}


/**PosChangeBtnTitleJS
 *
 * @brief - This BC changes the title of a button according to a received propertu message
 * Return - true 
 */
function PosChangeBtnTitleJS(btnNbr,msg,c1,c2,c3) {
	return(PosChangeBtnTitle_CSL(btnNbr,msg,c1,c2,c3));
}

/**PosIsBreakfastTimeJS
 *
 * @brief - This BC shows checks if it is breakfast time (or a flag is set indicating that) 
 * Return - true if breakfast time, false otherwise
 */
function PosIsBreakfastTimeJS() {
	return(PosIsBreakfastTime_CSL());

}

/**PosCheckClicksJS
 *
 * @brief - This BC decrements the number of clicks for a given screen and shows a new screen if the number of clicks is zeroed 
 * Return - true if breakfast time, false otherwise
 */
function PosCheckClicksJS(screenNbr) {
	return(PosCheckClicks_CSL(screenNbr));
}

/**PosCheckChoicesJS
 *
 * @brief - This BC checks for open choice of a kind
 * Return - rval - true if allowed to continue
 */
function PosCheckChoicesJS(choices) {
	return(PosCheckChoices_CSL(choices));				
}

/**PosIsSaleEmptyJS()
 *
 * @brief - This BC checks if a sale is empty 
 * Return - true if empty
 */
function PosIsSaleEmptyJS() {
	return(PosIsSaleEmpty_CSL());
}

/**PosSetSessionPropertyForAllJS
 *
 * @brief - This BC sets a session property in all registers online
 * Return - true if empty
 */
function PosSetSessionPropertyForAllJS(key,value,persist) {
	return(PosSetSessionProperty(key,value,persist,true));
}

/**
 * \defgroup VIEWCONS View Consolidation
 * \{
 */

/**
 * \brief Constructor of ConsolidatedView class
 * \param [in] view - View to consolidate in flat string format
 */
function ConsolidatedView (view) {
    this.view = new XML (view);		// Original view to be consolidated
}

/**
 * \brief Consolidates a view, returning its value in flat string format.
 * \return The consolidated view.
 */
ConsolidatedView.prototype.consolidate = function () {
    // Create array with sale items
    var newViewArray = this.detachChoice ();
    // Create the consolidated view
    var sortedView = this.createConsolidation (newViewArray);
    // Sort the Consolidated View
    this.sortView (sortedView);
    // Copies attributes from original view
    this.copyViewAttributes (sortedView);
    return sortedView.toXMLString();
}

/**
 * \brief Copies attributes from internal view to a provided view.
 * \param [in] view - View to add attributes to
 */
ConsolidatedView.prototype.copyViewAttributes = function (view) {
    for (var attr in this.view.@*) {
	view.@[this.view.@*[attr].name()] = this.view.@*[attr];
    }
}

/**
 * \brief Detaches choices from a given view. 
 *
 * \return Returns a view with choices put outside value meals.
 */
ConsolidatedView.prototype.detachChoice = function () {
    // Create array with sale items
    var itemChoice=new Array();
    var qtyPromoLevelZero=0;
    var qtyLevelZero=0;
    var qtyViewItem=this.view.ItemView.length();
    var newViewArray = new Array ();
    for(var i=0; i < qtyViewItem; i++) {
	var item=this.view.ItemView[i];
	if(Number(item.level) == 0) {
            qtyLevelZero=Number(item.quantity);
            qtyPromoLevelZero=Number(item.quantityPromo);
	}
	// Verify Choice
	if((Number(item.level) > 0) && (Number(item.prodAction) == 3)) {
            if(Number(item.productType) != 4) {
		// This is Choice
		item.quantityPromo=qtyPromoLevelZero*item.quantity;
		item.quantity*=qtyLevelZero;
		var levelChoice=Number(item.level);
		item.level=0;
		itemChoice.push({item:XML(item)});
		for(var j=i+1; j < qtyViewItem; j++) {
                    var itemChoiceB=this.view.ItemView[j];
                    if(itemChoiceB.level > levelChoice) {
			itemChoiceB.level-=levelChoice;
			itemChoiceB.quantity*=item.quantity;
                    }
                    else {
			break;
                    }
		}
            }
	}
	else {
            // This is not Choice
            newViewArray.push({item:XML(item)});
	}
    }
    // Put choice items at array's end
    for(var i=0; i < itemChoice.length; i++) {
	var iInd=newViewArray.length;
	newViewArray.push({item:XML(itemChoice[i].item)});
    }
    return newViewArray;
}

/** 
 * \brief Create a consolidated view.
 *
 * \param [in] viewArray - Array representing a view
 */
ConsolidatedView.prototype.createConsolidation = function (viewArray) {
    //Recreate Original XML
    var auxXML=new XML("<View/>");
    for(var i=0; i < viewArray.length; i++) {
	var ItemXML=XML(viewArray[i].item);
	auxXML.ItemView+=ItemXML;
    }
    var szViewArray=new Array();
    var szAux="";	
    var i=0;
    // Create  line array with the same iItemCode
    while(i < viewArray.length) {
	var ItemView=viewArray[i].item;
	var iItemCode = ItemView.itemCode.toString();
	szAux =szAux + ItemView.productCode + ItemView.grilledQuantity;
	for(var j=i+1; j < viewArray.length; j++) {		
	    var nextItemView=viewArray[j].item;
	    if((iItemCode!=nextItemView.itemCode) || (nextItemView.level==0)){
		break;
	    }
	    szAux=szAux + nextItemView.productCode + nextItemView.grilledQuantity;
	}
	szViewArray.push({id:String(i), item:String(szAux)});
	szAux="";
	i=j;
    }	
    for(var i = 0; i < szViewArray.length; i++) {
	var ItemArray = szViewArray[i].item;
	var iInd = Number(szViewArray[i].id);
	for(var j = i+1; j < szViewArray.length; j++) {		
	    if(ItemArray == szViewArray[j].item) {
		// Item already used in table	
		var jInd = Number(szViewArray[j].id);
		szViewArray[j].item = -j;  

		auxXML.ItemView[iInd].quantity = Number (auxXML.ItemView[iInd].quantity.toString()) 
		    + Number (auxXML.ItemView[jInd].quantity.toString());
		auxXML.ItemView[iInd].quantityPromo = Number(auxXML.ItemView[iInd].quantityPromo.toString()) 
		    + Number (auxXML.ItemView[jInd].quantityPromo.toString());
		auxXML.ItemView[iInd].unitPrice = Number(auxXML.ItemView[iInd].unitPrice.toString()) 
		    + Number (auxXML.ItemView[jInd].unitPrice.toString());					
		auxXML.ItemView[iInd].netUnitPrice = Number(auxXML.ItemView[iInd].netUnitPrice.toString()) 
		    + Number (auxXML.ItemView[jInd].netUnitPrice.toString());					
		auxXML.ItemView[iInd].unitTax = Number(auxXML.ItemView[iInd].unitTax.toString()) 
		    + Number (auxXML.ItemView[jInd].unitTax.toString());					
		auxXML.ItemView[iInd].totalPrice = Number(auxXML.ItemView[iInd].totalPrice.toString()) 
		    + Number (auxXML.ItemView[jInd].totalPrice.toString());					
		auxXML.ItemView[iInd].netTotalPrice = Number (auxXML.ItemView[iInd].netTotalPrice.toString()) 
		    + Number (auxXML.ItemView[jInd].netTotalPrice.toString());					
		auxXML.ItemView[iInd].totalTax = Number(auxXML.ItemView[iInd].totalTax.toString()) 
		    + Number (auxXML.ItemView[jInd].totalTax.toString());					
		auxXML.ItemView[iInd].ADTotalPrice = Number(auxXML.ItemView[iInd].ADTotalPrice.toString()) 
		    + Number(auxXML.ItemView[jInd].ADTotalPrice.toString());					
		auxXML.ItemView[iInd].ADNetTotalPrice = Number(auxXML.ItemView[iInd].ADNetTotalPrice.toString()) 
		    + Number(auxXML.ItemView[jInd].ADNetTotalPrice.toString());					
		auxXML.ItemView[iInd].ADTotalTax = Number(auxXML.ItemView[iInd].ADTotalTax.toString()) 
		    + Number(auxXML.ItemView[jInd].ADTotalTax.toString());					
		auxXML.ItemView[jInd].quantity = 0;
	    }
	}
    }
    return auxXML;
}

/**
 * \brief Sorts a consolidated view
 * 
 * \param [in, out] newViewCons - Consolidated view to sort, as a XML object
 */
ConsolidatedView.prototype.sortView = function (newViewCons) {
    var flagdisplayOrder=false;
    // Create array to search duplicated displayOrder
    var displayOrderArray = new Array();
    for each (var item in newViewCons.ItemView) {
	if (Number(item.level) == 0) {
	    displayOrderArray.push({id:Number(item.displayOrder)});
	}
    }
    // Sort displayOrder Array
    displayOrderArray.sort(function compareNumbers(a,b){return (Number(a.id) - Number(b.id));})		
    //Seach duplicate displayOrder
    for(var i=1; i < displayOrderArray.length; i++) {
	if(displayOrderArray[i-1].id == displayOrderArray[i].id){
	    // There is duplicate displayOrder
	    flagdisplayOrder=true;
	    break;
	}
    }
    
    // Create array with sale items
    var newViewArray = new Array();
    var key = "000000000";
    var displayOrder = "000000000";
    var productCode = "";
    for each (var item in newViewCons.ItemView) {
	if (Number(item.level) == 0) {
	    key = API.formatNumber(Number(item.displayOrder), "000000000", 9)
	}
	displayOrder = API.formatNumber(Number(item.displayOrder), "000000000", 9)
	if (flagdisplayOrder==true) {
	    productCode = API.formatNumber(Number(item.productCode), "00000", 5)
	}
	// Create key to sort
	var aux = String(key) + Number(item.level) + String(displayOrder)+ String(productCode);		
	newViewArray.push({id:String(aux), item:String(item)});
    }
    // Sort array with sale items
    newViewArray.sort(function compareNumbers(a,b){return (Number(a.id) - Number(b.id));});		
    
    var sortViewCons = new XML("<View/>");
    for(var i = 0; i < newViewArray.length; i++) {
	var ItemView = new XML(newViewArray[i].item);
	sortViewCons.ItemView+=ItemView;
    }
    
    newViewCons = sortViewCons;
}

/**
 * \brief Entry point called by kernel in order to consolidate a view
 * \param [in] view - View to consolidate in string format
 * \return Consolidated view in string format
 */
function onConsolidateView (view) {
    var cnView = new ConsolidatedView (view);
    return cnView.consolidate();
}

/** \} */

/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/
/*end logic from businessComponents.nps*/
/*------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------*/

		// *** Added In Line With Gap Analysis Technical Notes ***
		// *** Chris Appleton, 23rd July 2008 ***

		/** 
		 * @brief - determines if a tender type is valid 
		 * @return - true if valid tender type, false otherwise 
		 */ 
		function PosCheckTenderIdJS(desired_Id) { 
		// Create an POSDB object to access pos-db/store-db data 
      
		var hlp = new BusinessObjectHelper; 
		var tender=hlp.getTenderDescr(desired_Id); 
		if(tender != null) { 
	          		return(true); 
	     		} 
     		return(false); 
		}

/**PosDoSaleByWeekDayJS
 *
 * @brief - BC to allow sale of different items for different days of the week e.g. deli of the day
 * author - Jon Smith 2008-08-28
 * Return - result of PosDoSaleJS
 */
function PosDoSaleByWeekDayJS(ProductCodeDay0,ProductCodeDay1,ProductCodeDay2,ProductCodeDay3,ProductCodeDay4,ProductCodeDay5,ProductCodeDay6) {
	if(PosIsWeekDay(0)) {
		var ProductCode=ProductCodeDay0;
	} else if(PosIsWeekDay(1)) {
		var ProductCode=ProductCodeDay1;
	} else if(PosIsWeekDay(2)) {
		var ProductCode=ProductCodeDay2;
	} else if(PosIsWeekDay(3)) {
		var ProductCode=ProductCodeDay3;
	} else if(PosIsWeekDay(4)) {
		var ProductCode=ProductCodeDay4;
	} else if(PosIsWeekDay(5)) {
		var ProductCode=ProductCodeDay5;
	} else {
		var ProductCode=ProductCodeDay6;
	}
	return(PosDoSaleJS(ProductCode));
}		

/**PosDoSaleByWeekDayListJS
 *
 * @brief - BC to allow sale of different items for different days of the week e.g. deli of the day
 * author - Jon Smith 2008-08-28
 * Return - result of PosDoSaleJS
 */
 function PosDoSaleByWeekDayListJS(ProductList) {
	if((ProductList != undefined) && (ProductList != null)) {
		var ProductArray=ProductList.split(",");
		if((ProductArray != null) && ProductArray.length == 7) {
			if(PosIsWeekDay(0)) {
				var ProductCode=ProductArray[0];
			} else if(PosIsWeekDay(1)) {
				var ProductCode=ProductArray[1];
			} else if(PosIsWeekDay(2)) {
				var ProductCode=ProductArray[2];
			} else if(PosIsWeekDay(3)) {
				var ProductCode=ProductArray[3];
			} else if(PosIsWeekDay(4)) {
				var ProductCode=ProductArray[4];
			} else if(PosIsWeekDay(5)) {
				var ProductCode=ProductArray[5];
			} else {
				var ProductCode=ProductArray[6];
			}
			return(PosDoSaleJS(ProductCode));
		}
	}
	return(false);
}

//can be used for every report that need to have a start time and an end time set
//these horus will be send in  custom parameters in the report
function ReportByTimePeriod(DataTypes, ReportScript, Flags, POD, ServiceList)
{
	var hlp = new BusinessObjectHelper;
	//test if the data is valid
    var error =true;
	
	//to do test if the date is good
	//var date = hlp.showCalculator ("Enter the bussiness day","2");
	var startHour="";
	while (error)
	{
	   var startHour = hlp.showCalculator (API.getLocalMsg("MSG_CALCULATOR_UPTHR_START"),"1");
	   if(startHour == "")
	   {
	      break;
	   }
	   else
	   {
		  if(Number(startHour.length) ==3)
		  {
			 startHour = "0"+startHour;
		  }
	   }
	   if(Number(startHour.substring(0,2))>24 || Number(startHour.substring(2,4))>60 || startHour.length !=4)
	   {
			error=true;
	   }
	   else
	   {
	      break;
	   }
	}
	
	if (startHour !="")
	{
		while (error)
		{
		   var endHour = hlp.showCalculator (API.getLocalMsg("MSG_CALCULATOR_UPTHR_END"),"1");
		   if(endHour == "")
		   {
				return;
		   }
		   else
		   {
		      if(Number(endHour.length) ==3)
			  {
			     endHour = "0"+endHour;
			  }
		   }
		   
		   if(Number(endHour.substring(0,2))>24 || Number(endHour.substring(2,4))>60 || endHour.length !=4)
		   {
				error=true;
		   }
		   else
		   {
		      break;
		   }
		}
	}
	
    //call the report
	if (startHour !="")
	{
		var CustomParam = startHour+","+endHour; 
		PosCreateReport (DataTypes, ReportScript, Flags, CustomParam, POD, ServiceList);
	}
}

/*
This function will execute a remote BC on every POS defined in the list
@ param
	functionName -BC taht will be executed remotly.
*/
function PosRemoteRemoteByListJS(functionName)
{
	//get the pos list
	var hlp=new BusinessObjectHelper; 
	var item = hlp.getReportXML("WAY_GetPosList","CONSOLIDATED");
	if(item ==null || item ==undefined || item+""=="")
	{
		PosShowMessage("MSG_WAY_NOTREADY");
		return false;
	}
	var report = item[1].toString();
	report = report.replace("<?xml version=\"1.0\" encoding=\"UTF-8\"?>",""); //need to remove this oterwise we cannot convert the respot to XML
	var rep = new XML(report.toString()); 
	var list="";
	var globalResult = true;
	var message = "";
	
	//get the current pos id, (because for this id the 
	if(runGetConfig_Eurecs == true)
	{
		PosCreateReport ("CASH","GetConfigInfo@eurecs.nps", "", "");
	}
	for(var i=0; i < rep.PosList.Pos.length(); i++)
	{
		
		var itemID = rep.PosList.Pos[i].@id+"";
		if(Number(PosId.substring(3)) != Number(itemID.substring(3)))
		{
			var result = true;
			if(functionName == "InitCashless")
			{
				result =PosRemoteExecute(itemID,functionName,true,false);
			}
			else
			{
				result = PosRemoteExecute(itemID,functionName);
			}
			
			if(result == false)  //if is failing for a register then we return false.
			{
				globalResult = result;
				API.dbg("PosRemoteExecute failed for: "+itemID + "function "+functionName);
			}
		}
		else  //execute locally
		{
			if(functionName == "InitCashless")
			{
				result = eval(functionName+"(true,false)");
			}
			else
			{
				result = eval(functionName+"()");
			}
			if(result == false)  //if is failing for a register then we return false.
			{
				globalResult = result;
				API.dbg("PosRemoteExecute failed for: "+itemID + "function "+functionName);
			}
		}
		
	}
	//executed for the current POS 
	return globalResult;

}

/*France cashless update  on current register*/
function CashlessUpdateJS()
{
	if(!PosCheckParameter("TCLExtension","everest","true")) 
	{
		API.dbg("no e-cash system adaptor defined");
		return true; //no e-cash system defined
	}

	if(Country == "FR")
	{
		var result  = npTCLEvalEx("Eurecs_TransfertCaisseFR");
		switch(result)
			{
			case "0": 
			{
					PosShowMessage("MSG_UPDATE_ECASH_OK");
					//init e-cash again 
					InitCashless(true,false);
					break;
			}
			case "1":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR1");
					break;
			}
			case "2":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR2");
					break;
			}
			case "3":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR3");
					break;
			}
			case "4":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR4");
					break;
			}
			case "9":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR9");
					break;
			}
			case "-1":
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR_MISSINGEXE");
					break;
			}
			default:
			{
					PosShowMessage("MSG_UPDATE_ECASH_ERROR");
					break;
			}
		}
	}
	return true;
}

/*
This function will initialiase the cashless system offline on the current register
*/
function InitOfflineCashlessJS()
{
	API.dbg("Begin InitOfflineCashless");
	if(!PosCheckParameter("TCLExtension","everest","true")) 
	{
		API.dbg("no e-cash system adaptor defined");
		return true; //no e-cash system defined
	}
		
	if(Country=="FR")
	{
		if(runGetConfig_Eurecs ==true)
		{
			PosCreateReport ("CASH","GetConfigInfo@eurecs.nps", "", ""); // This is to get the configuration  
		}
		if(OperatorID != "" && OperatorID != null && OperatorID != "0" && businessDate_Eurecs+"" !="")
		{
			
			var InitResult = npTCLEvalEx("Eurecs_C3OfflineFR " + businessDate_Eurecs + " " + StoreID  + " " + PosId.substring (3) + " " + OperatorID);
			if(InitResult== null || InitResult == "")
			{
				API.dbg("InitOfflineCashless: CASHLESS Initialisation error");
				PosShowMessage("MSG_BC_GC_NOT_AVAILABLE");
			}
			var ParseInitResult = InitResult.split(" ");
			API.dbg("InitCashless ParseInitResult: " + ParseInitResult);
			if(Number(ParseInitResult[0]) == 0) 
			{
				PosShowMessage("MSG_CASHLESS_OFFLINE");
				PosSetSessionProperty("EftPosInitialized", "false", "true");		
				PosSetSessionProperty("PosInitializedOffline", "true", "true");					
			}
			else //initialization fails
			{
			   PosShowMessage("MSG_BC_GC_NOT_AVAILABLE");
			   PosSetSessionProperty("EftPosInitialized", "false", "true");
			   PosSetSessionProperty("PosInitializedOffline", "false", "true");	
			}
		}
		else
		{
			API.dbg("operation failed no user logged or not business day open ");
			//PosShowMessage("MSG_NO_USER_LOGGED");
		}
	}
	return true;
}

/*
@param flag- true or false  depends of the place this function is called
		 - false for onLogOutFinalise and if it is called from a workflow ; true for onLogInFinalize 
@param withCheck	-true if we need to check EftPosInitialized, otherwise false.
*/
function InitCashless(flag, withCheck)
{
	API.dbg("InitCashless starts with flag: " + flag + " withCheck: " + withCheck);
	if(!PosCheckParameter("TCLExtension","everest","true")) 
	{
		API.dbg("no e-cash system adaptor defined");
		return true; //no e-cash system defined
	}
  if(Country =="FR")
  {
		if(runGetConfig_Eurecs == true)
		{
			PosCreateReport ("CASH","GetConfigInfo@eurecs.nps", "", ""); // This is to get the configuration  
		}
		if(flag == true || flag == "true")
	    {   
			//28.04.2009 check if we can proceed without checking
			var allow = true;
			if(withCheck == true)
			{	
				if(PosCheckSessionProperty ("EftPosInitialized", "true"))
				{
					allow = false;
				}
			}						
			if(allow)
			{
			    //API.dbg("OnLoginFinalize Eurecs_C3InitFR");
				if(OperatorID!="" && OperatorID!=null && OperatorID!="0" && businessDate_Eurecs+"" !="")
				{
					
					var InitResult = npTCLEvalEx("Eurecs_C3InitFR " + businessDate_Eurecs + " " + StoreID  + " " + PosId.substring (3) + " " + OperatorID);
					if(InitResult== null || InitResult == "")
					{
						API.dbg("InitCashless: CASHLESS Initialisation error");
						return true;
					}
					var ParseInitResult = InitResult.split(" ");
					API.dbg("InitCashless ParseInitResult: " + ParseInitResult);
					if(Number(ParseInitResult[0]) == 0) 
					{
						if(Number(ParseInitResult[2]) == 1) //we are offline
						{
							PosShowMessage("MSG_CASHLESS_OFFLINE");
							PosSetSessionProperty("EftPosInitialized", "false", "true");		
							PosSetSessionProperty("PosInitializedOffline", "true", "true");								
						}
						else //This should be returned in case INIT has worked
						{    
							PosSetSessionProperty("EftPosInitialized", "true", "true");				
						}                      
					}
					else //initialization fails
					{
					   PosShowMessage("MSG_BC_GC_NOT_AVAILABLE");
					   PosSetSessionProperty("EftPosInitialized", "false", "true");
					   PosSetSessionProperty("PosInitializedOffline", "false", "true");	
					}
				}
				else
				{
					API.dbg("operation failed no user logged or not business day open ");
					//PosShowMessage("MSG_NO_USER_LOGGED");
				}
			}
	    }
	    else
		{
			//02.03.2009 OI set the query for the coutry around SetEurecsInfo, because this is only allowed for france
			if(PosCheckSessionProperty ("OfflineTransactions", "1")) //we have at least one offline transaction we must call the init function 
			{
			    //API.dbg("OnLogoutFinalize Eurecs_C3InitFR");
				var InitResult = npTCLEvalEx("Eurecs_C3InitFR " + businessDate_Eurecs + " " + StoreID  + " " + PosId.substring (3) + " " + OperatorID);
				if(InitResult== null || InitResult == "")
				{
					API.dbg("InitCashless: CASHLESS Initialisation error");
					return true;
				}
				var ParseInitResult = InitResult.split(" ");
				if(Number(ParseInitResult[0]) == 0) 
				{
					if(Number(ParseInitResult[2]) == 1) //we are offline
					{
						PosShowMessage("MSG_CASHLESS_OFFLINE");
						PosSetSessionProperty("EftPosInitialized", "false");	
						PosSetSessionProperty("PosInitializedOffline", "true", "true");							
					}
					else //This should be returned in case INIT has worked
		            {    
						PosSetSessionProperty ("OfflineTransactions", "0", "true"); // this needs to be reset as the init should only be called once
		            }                         // after offline transactions have been made.
				}
				else //initialization fails
				{
					PosShowMessage("MSG_BC_GC_NOT_AVAILABLE");
					PosSetSessionProperty("EftPosInitialized", "false");
					PosSetSessionProperty("PosInitializedOffline", "false", "true");	
				}
			}
		}
 	}
	return true;
}

var oldsaleview = "";
var selelectedLine= "";
function storeChoices()
{
	//back from total 
	//PosDoBackFromTotal(); 

	var hlp = new BusinessObjectHelper;
	var xmlView = new XML(hlp.getCurrentView());
	oldsaleview = hlp.getCurrentView();
	API.dbg("currentsaleview "+ xmlView);
	//get selected item
	var item = new XML(hlp.getSaleItem(-1,0));
	itemProdCode = item.@id;
	
	//find the selected line
	selelectedLine = hlp.getSelIndex();
	//if we have void lines then this index will not be good.
	var cnt=0;
	var i=0;
	for (i=0; i<1000;i++)
	{
		if(getQuantity(i) == 0)
		{
			cnt=cnt;
		}
		else
		{
			if(cnt == Number(selelectedLine))
				break;
			cnt++;
		}
	}
	//API.DbgMessageBox(selelectedLine+" "+ i);
	selelectedLine = i;
	
	//API.DbgMessageBox(selelectedLine+" " +xmlView.ItemView.(Number(itemCode) == Number(selelectedLine))[0].productCode);
	return true;
	//reset the content of the store item choice
	
}
function rebuildChoice()
{
	var xmlOldView= new XML(oldsaleview);
    //API.DbgMessageBox("rebuildChoice "+ selelectedLine);
	API.dbg("rebuildChoice oldview"+ xmlOldView);
	var hlp = new BusinessObjectHelper;
	var xmlView = new XML(hlp.getCurrentView());
	//get the changed product code
	var currentPrice =0;
	var currentNetPrice =0;
	var currentTax =0;
	var productCode = 0; 
	//API.dbg("test123 "+ xmlView.ItemView.(currentSelected==true || currentSelected == "true"));
	if( xmlView.ItemView.(currentSelected==true || currentSelected == "true")+"" != "")
	{
		currentPrice = new BigDecimal((xmlView.ItemView.(currentSelected==true || currentSelected == "true"))[0].unitPrice);
		currentNetPrice = new BigDecimal((xmlView.ItemView.(currentSelected==true || currentSelected == "true"))[0].netUnitPrice);
		currentTax = new BigDecimal((xmlView.ItemView.(currentSelected==true || currentSelected == "true"))[0].unitTax);
		productCode = (xmlView.ItemView.(currentSelected==true || currentSelected == "true"))[0].productCode;
	}
	else //when we make the upgrade the selected line was consolidated with another one
	{
	    //we must check for the line that change its qunatity size  and is value meal
		for each (var product in xmlView.ItemView.(productType=="3"))
		{
			var lineIndex= Number(product.itemCode);
			var qty = product.quantity;
			if( xmlOldView.ItemView[lineIndex].quantity != qty)
			{
				//take the product price
				currentPrice = new BigDecimal(product.unitPrice);
				currentNetPrice = new BigDecimal(product.netUnitPrice);
				currentTax = new BigDecimal(product.unitTax);
				productCode = product.productCode; 
				break;
			}			
			
		}
	}
	var product= (xmlOldView.ItemView.(Number(itemCode)==Number(selelectedLine)))[0];
	//API.DbgMessageBox(selelectedLine+ " " +product.productCode);
	//update header
	xmlOldView.@BPTotalAmount += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.@BPGrossAmount += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.@BPTotalTax	  += Number((currentTax.subtract(product.unitTax)).toString());	
	xmlOldView.@BDTotalAmount += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.@BDTotalAmount += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.@BDTotalTax	  += Number((currentTax.subtract(product.unitTax)).toString());	
	xmlOldView.@totalAmount	  += Number((currentPrice.subtract(product.unitPrice)).toString());
	
	xmlOldView.@grossAmount	  += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.@totalTax	  += Number((currentTax.subtract(product.unitTax)).toString());
	xmlOldView.@totalDue	  += Number((currentPrice.subtract(product.unitPrice)).toString());
	xmlOldView.taxItem.(@id==product.taxChain.tax.@id).@baseAmt += Number((currentNetPrice.subtract(product.netUnitPrice)).toString());
	xmlOldView.taxItem.(@id==product.taxChain.tax.@id).@amount += Number((currentTax.subtract(product.unitTax)).toString());
	
	//update sandwidch
	(xmlOldView.ItemView.(Number(itemCode)==Number(selelectedLine)))[0].productCode = productCode;//(xmlView.ItemView.(currentSelected==true || currentSelected == "true"))[0];
	//(xmlOldView.ItemView.(Number(itemCode)==Number(selelectedLine)))[0].quantityChanged= false;
	
	API.dbg("xmlOldView1234 "+ xmlOldView);
	hlp.setCurrentView(xmlOldView);	
	PosRefreshSalePanel();
	//PosDoTotalJS("1",TENDER_SCREEN_NBR, STORE_SCREEN_NBR, "NOPREVIEW|SAVE");
	//do total again
	
	return true;
}


// the function checks if there will be a tender excess 
//if there will be it returns true else false
//params: tenderID
function PosCheckTenderExcess(tenderID)
{
	
	//test if is a keep excess tender 
	var keepExcess = xmlStoreDB.StoreDB.TenderTypes.TenderType.(Number(TenderId)==Number(tenderID)).TenderChange.@type;

	var boolKeepEx =false;
	if(keepExcess == "KEEP_EXCESS")
	{
		boolKeepEx = true;
	}
	if(boolKeepEx) //test if the amount is bigger then the sale
	{
		var hlp = new BusinessObjectHelper;
		var viewXML = new XML(hlp.getCurrentView());
		if(viewXML == null)
		{
			viewXML = new XML(hlp.getLastView());
		}
		//if we pay previous for this order we must subtract that too
		var summ =0;
		for each (var tenderOp in viewXML.ItemTenderView)
		{
			summ = Number(summ)+ Number(tenderOp.value);
		}
		if( Number(viewXML.@grossAmount) < Number(summ) )
		{
			return true;
		}
	}
	
	return false;
}


//index the item code
function getQuantity(index)
{
	var hlp = new BusinessObjectHelper;
	var xmlView = new XML(hlp.getCurrentView());
	
	var products = xmlView.ItemView.(Number(itemCode)==Number(index));
	for each (product in products)
	{
		if(Number(product.quantity) > 0)
		{
			return 1;
		}
	}
	return 0;
}

//plus minus qunatity
//flag =1 plus
//flag =- minus
function PosChangeItemQuantity(flag)
{
	var hlp = new BusinessObjectHelper;
	var xmlView = new XML(hlp.getCurrentView());
	API.dbg("before change xmlview "+xmlView);
	//get selected line
	var selelectedLine = hlp.getSelIndex();
	
	//if we have void lines then this index will no tbe good.
	var cnt=0;
	var i=0;
	for (i=0; i<1000;i++)
	{
		if(getQuantity(i) == 0)
		{
			cnt=cnt;
		}
		else
		{
			if(cnt == Number(selelectedLine))
				break;
			cnt++;
		}
	}
	//API.DbgMessageBox(selelectedLine+" "+ i);
	selelectedLine = i;
	
	
	var newCurrentView = xmlView;
	if(flag =="1")
	{
		for each (product in  newCurrentView.ItemView)
		{
			if(Number(product.itemCode) == Number(selelectedLine) && Number(product.level) == 0 && Number(product.quantity) ==0)
			{
				return;
			}
			if (Number(product.itemCode) == Number(selelectedLine) &&  Number(product.quantity) !=0)
			{
				//update header information
				//update header information
				newCurrentView.@BPTotalAmount += Number(product.unitPrice);
				newCurrentView.@BPGrossAmount += Number(product.unitPrice);
				newCurrentView.@BPTotalTax	  += Number(product.unitTax);	
				newCurrentView.@BDTotalAmount += Number(product.unitPrice);
				newCurrentView.@BDGrossAmount += Number(product.unitPrice);
				newCurrentView.@BDTotalTax	  += Number(product.unitTax);	
				newCurrentView.@totalAmount	  += Number(product.unitPrice);
				
				newCurrentView.@grossAmount	  += Number(product.unitPrice);
				newCurrentView.@totalTax	  += Number(product.unitTax);
				newCurrentView.@totalDue	  += Number(product.unitPrice);
				newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@baseAmt += Number(product.netUnitPrice);
				newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@amount += Number(product.unitTax);
			
				//update product information
				product.quantity = Number(product.quantity)+1;
				product.totalPrice = Number(product.totalPrice) +  Number(product.unitPrice);
				product.netTotalPrice =  Number(product.netTotalPrice) +  Number(product.netUnitPrice);
				product.totalTax = Number(product.totalTax) +  Number(product.unitTax);
				product.ADTotalPrice = Number(product.ADTotalPrice) +  Number(product.unitPrice);
				product.ADNetTotalPrice = Number(product.ADNetTotalPrice) +  Number(product.netUnitPrice);
				product.ADTotalTax =  Number(product.ADTotalTax) +  Number(product.unitTax);
				product.taxChain.tax.@amount = Number(product.taxChain.tax.@amount) +  Number(product.unitTax);
				product.taxChain.tax.@baseAmt = Number(product.taxChain.tax.@baseAmt) +  Number(product.unitTax);
				product.quantityChanged = true;
				break;
			}
		}
	}
	else //we must reduce the quantity with one
	{
		for each (product in  newCurrentView.ItemView)
		{
			if(Number(product.itemCode) == Number(selelectedLine) && Number(product.level) == 0 && ( Number(product.quantity) == 1 || Number(product.quantity) == 0) )
			{
				return;
			}
			if (Number(product.itemCode) == Number(selelectedLine) &&  Number(product.quantity) !=0)
			{
			
				//update header information
				newCurrentView.@BPTotalAmount = ((new BigDecimal(newCurrentView.@BPTotalAmount)).subtract(product.unitPrice)).toString();
				newCurrentView.@BPGrossAmount = ((new BigDecimal(newCurrentView.@BPGrossAmount)).subtract(product.unitPrice)).toString();
				newCurrentView.@BPTotalTax	  = ((new BigDecimal(newCurrentView.@BPTotalTax)).subtract(product.unitTax)).toString();	
				newCurrentView.@BDTotalAmount = ((new BigDecimal(newCurrentView.@BDTotalAmount)).subtract(product.unitPrice)).toString();
				newCurrentView.@BDGrossAmount = ((new BigDecimal(newCurrentView.@BDGrossAmount)).subtract(product.unitPrice)).toString();
				newCurrentView.@BDTotalTax	  = ((new BigDecimal(newCurrentView.@BDTotalTax)).subtract(product.unitTax)).toString();	
				newCurrentView.@totalAmount	  = ((new BigDecimal(newCurrentView.@totalAmount)).subtract(product.unitPrice)).toString();
				
				newCurrentView.@grossAmount	  = ((new BigDecimal(newCurrentView.@grossAmount)).subtract(product.unitPrice)).toString();
				newCurrentView.@totalTax	  = ((new BigDecimal(newCurrentView.@totalTax)).subtract(product.unitTax)).toString();
				newCurrentView.@totalDue	  = ((new BigDecimal(newCurrentView.@totalDue)).subtract(product.unitPrice)).toString();
				newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@baseAmt = ((new BigDecimal(newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@baseAmt)).subtract(product.netUnitPrice)).toString();
				newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@amount = ((new BigDecimal(newCurrentView.taxItem.(@id==product.taxChain.tax.@id).@amount)).subtract(product.unitTax)).toString();

				//update product information
				product.quantity = Number(product.quantity)-1;
				product.totalPrice = ((new BigDecimal(product.totalPrice)).subtract(product.unitPrice)).toString();
				product.netTotalPrice = ((new BigDecimal(product.netTotalPrice)).subtract(product.netUnitPrice)).toString();
				product.totalTax =  ((new BigDecimal(product.totalTax)).subtract(product.unitTax)).toString();
				product.ADTotalPrice = ((new BigDecimal(product.ADTotalPrice)).subtract(product.unitPrice)).toString();
				product.ADNetTotalPrice = ((new BigDecimal(product.ADNetTotalPrice)).subtract(product.netUnitPrice)).toString();
				product.ADTotalTax =  ((new BigDecimal(product.ADTotalTax)).subtract(product.unitTax)).toString();
				product.taxChain.tax.@amount = ((new BigDecimal(product.taxChain.tax.@amount)).subtract(product.unitPrice)).toString();
				product.taxChain.tax.@baseAmt = ((new BigDecimal(product.taxChain.tax.@baseAmt)).subtract(product.unitTax)).toString();
				product.quantityChanged = true;
				break;
			}
		}
	}
	hlp.setCurrentView(newCurrentView);	
	PosRefreshSalePanel();
	API.dbg("after change xmlview "+ newCurrentView);
	return true;
}

function GetConfigInfo (config, data)
{
	var rootCash;
	runGetConfig_Local = false;  //call it just once
	initGlobalt();
	
	//API.dbg ("  getConfigInfo  " + config);
	rootConfig = new XML(config);
	API.dbg ("  GETConfigInfo" + rootConfig.Country);
	Country = rootConfig.Country.toUpperCase();
	PosID_Local   = rootConfig.PosId;
	StoreID_Local = rootConfig.StoreId;
	for(var i = 0; i < data.length; i++)
	{
	   if(data[i] != null)
	   {
			var xml = new XML(data[i]);
			var dataType = xml.@requestDataType.toLowerCase();			
			API.dbg ("Reports init - dataType XML" + dataType);			
			if("cash" == dataType) 
			{
				rootCash = xml;
			}
		}
	}		
	businessDate_Local = rootCash.POS.@businessDate; 
	var length = rootCash.POS.OperatorSession.length();
	var operatorSession = rootCash.POS.OperatorSession;
	if(operatorSession!=null && Number(length) != 0)
	{
		 operatorID_Local = operatorSession[length-1].@id; 
		 API.dbg("getBCLocalInfo OperatorID " + operatorID_Local);
	}
	
// <StoreId>1275</StoreId>
// <PosId>POS001</PosId>
// <Header>\nThank You For Eating At\nYardley Wood</Header> 
// <Footer>Vat Number : 371057172</Footer> 
// <StoreName>Yardley Wood</StoreName> 
// <StoreAddress>Yardley Wood</StoreAddress>
// <StoreZipCode>B14 4BJ</StoreZipCode>
// <City>Birmingham</City>
// <Country>UK</Country>
// <StorePhoneNumber>0121 430 4214</StorePhoneNumber>
// <Email></Email>
// <HomePage></HomePage>
// <HelpDeskInfo>0000-00-0000</HelpDeskInfo>
// <Locale>en_UK</Locale>
// <DateFormat>dd-MM-yyyy</DateFormat>
// <ReportFlags>NOPREVIEW</ReportFlags>
// <DataTypes>CASH</DataTypes>
// <Manager id="3" name="Carl Sagan"/>	

	return outputBuffer;
}


//--------------------------
// HB SOTEC
// Get Business date / Store ID
// Explanation from TOREX:
//
// Currently there is no "direct" helper to get the business date, the easiest way to get it in the current version is use a helper to get a "CASH" report and parse it. 
// This is a JavaScript example: 
//------------------------------------
function GetGlobalInfoLocal (sType)
{
// Create a instance of BusinessObjectHelper 
var hlp=new BusinessObjectHelper; // Create the CASH report 
var item = hlp.getReportXML("CASH"); 
API.dbg("GetGlobalInfoLocal "+ item);
// The returned value is an XML array, where: 
// first array position: configuration XML 
// second array position: CASH  report XML // Parse the returned value (just need to parse CASH report XML): 
var rep = new XML(item[1].toString()); 
// Get the required data 
var storeID = rep.@storeId; 
var busDate = rep.POS.@businessDate; 

//	API.dbg ("  GetGlobalInfoLocal " + rep);
//Examples of generated reports (from the Head version): 
//1) First array position: configuration report: 
//<ReportConfiguration creationDate="20080114 10:17:52" > 
//<StoreId>3381</StoreId> 
//<PosId>POS013</PosId> 
//<Header>\nThank You For Eating At\nROMEOVILLE MCDONALDS\n\n1120 22ND ST\nOAK BROOK, IL 60523\n\nTHANK YOU\n\nSPRING ROAD      TEL# (630)368-1173</Header> 
//<Footer>none</Footer> 
//<StoreName>ROMEOVILLE</StoreName> 
//<StoreAddress>1300 MARQUETTE DR.,</StoreAddress> 
//<StoreZipCode>60446</StoreZipCode> 
//<City>ROMEOVILLE, IL</City> 
//<Country>US</Country> 
//<StorePhoneNumber>630-759-2192</StorePhoneNumber> 
//<Email></Email> 
//<HomePage></HomePage> 
//<HelpDeskInfo>0000-00-0000</HelpDeskInfo> 
//<Locale>en_US</Locale> 
//<DateFormat>MM-dd-yyyy</DateFormat> 
//<ReportFlags></ReportFlags> 
//<DataTypes>CASH</DataTypes> 
//<Manager id="3" name="Carl Sagan"/> 
//</ReportConfiguration> 
    if (sType == "STOREID")
        {
        return storeID;
        }

    if (sType == "BDATE")
        {
        return busDate;
        }

 return "";
}

/*
* Helper function
* Parameters: storeDbPath - path to the desired parameter in store-db
*			  psoDbpath -path to the desired parameter in pos-db
* Returns the value of a configuration parameter
*/
 function getConfigValue(storeDbPath, posDbPath)
 {
	if(posDbPath!="" && posDbPath!=null)
	{
		var value = eval("xmlPosDB."+posDbPath);
		if(value+""!="")
		{
			return  value;
		}
	}
	return  eval("xmlStoreDB."+storeDbPath)+"";
		
 }

 /**
 * @brief - determins if a tender type is invalid and hide the  supplied button if it is not
 * @return - void
 */
function PosHideCouponsIfInvalidJS(ButtonNumber, TenderID) {
	if (validateTenderIdJS(TenderID) == false) {
		PosChangeButtonProperties(ButtonNumber, "visible|false");
	}
}

/**
 *  @brief - determines if a tender type is valid
 * @return - true if valid tender type, false otherwise
 */
function validateTenderIdJS(desired_Id) {
	// Create an POSDB object to access pos-db/store-db data
	
	var hlp = new BusinessObjectHelper;
	var tender=hlp.getTenderDescr(desired_Id);
	if(tender != null) {
		return(true);
	}
	return(false);
}

/**
 * @brief - Assemble and show the confirmation message with the date to rollback to
 * @return - true if msg confirmation or false otherwise
 */
function PosShowRollbackConfirmationMessage() {
	var ctx=new SessionContext;
	var nRollDate=ctx.get("SELECTED_ROLLDATE");
	var ret=0;
	if(null!=nRollDate) {
		var hlp=new BusinessObjectHelper;
		var sConfMsg=hlp.getSysMessage("MSG_BC_CFGROLLBACK_CONF_DATE", nRollDate);
		ret=PosShowConfirmationMessage(sConfMsg,"MSG_OK","MSG_CANCEL",1,nRollDate);
	}
	return(ret);
}


/**
 * @brief - Assemble and show the Second confirmation message with the date to rollback to
 * @return - true if msg confirmation or false otherwise
 */
function PosShowDblRollbackConfirmationMessage() {
	var ctx=new SessionContext;
	var nRollDate=ctx.get("SELECTED_ROLLDATE");
	var ret=0;
	if(null!=nRollDate) {
		var hlp=new BusinessObjectHelper;
		var sConfMsg=hlp.getSysMessage("MSG_BC_CFGROLLBACK_DOUBLECONF_DATE", nRollDate);

		ret=PosShowConfirmationMessage(sConfMsg,"MSG_OK","MSG_CANCEL",1,nRollDate);
	}
	return(ret);
}

/**
 * @brief - Assemble and show the message with the manifest dat date
 * @return - true if msg confirmation or false otherwise
 */
function PosShowMessageWithManifestDate(message) {
	var hlp=new BusinessObjectHelper;
	var manifestDate=hlp.getManifestDate();
	var ret=0;
	var sMsg;
	if(null!=manifestDate) {
		if(0!=Number(manifestDate)) {
			sMsg=hlp.getSysMessage(message, manifestDate);
		}
		else {
			sMsg=hlp.getSysMessage("MSG_BC_CFGROLLBACK_NODE_OFF");
		}
	}
	else {
		sMsg=hlp.getSysMessage(message, "");
	}
	ret=PosShowMessage(sMsg);
	return(ret);
}

/**
 * @brief - Assemble and show the Second confirmation message with the date to rollback to
 * @return - true if msg confirmation or false otherwise
 */
function PosShowMessageLockStatus() {
	var ctx=new SessionContext;
	var nLockSalesStatus=Number(ctx.get("lockSalesStatus"));
	var ret=0;
	var hlp=new BusinessObjectHelper;

	switch(nLockSalesStatus) {
	case 2:		// POS offline
		PosShowMessage("MSG_BC_CFGROLLBACK_NODE_OFF");
		break;
	case 3:		// WAY offline
		PosShowMessage("MSG_BC_CFGROLLBACK_WAY_FAILED");
		break;
	case 1:		// lock error
		// fall thru
	default:
		PosShowMessage("MSG_BC_CFGROLLBACK_CANNOT_BLOCK");
		break;
	}

	return(ret);
}

/**
 * @brief - Set the aspect of the button dimension when show prices is true
 */
function PosShowPricesSizeSelectionJS(btnSize,IsFloat) {
	var hlp = new BusinessObjectHelper;
	var actualSize = hlp.getSizeSel();

	if(actualSize == btnSize) {
		PosChangeButtonProperties(0,"invert|true",IsFloat);
	}
	else {
		PosChangeButtonProperties(0,"invert|false",IsFloat);
	}
}
 
 
 /*alow automatic print to be disable */
 function RepEnablePrintFilterJS(change) {
	const reportType=["on","off"];
	const properties=[
		"bitmap|YES.png,bitmapdn|YES.png,title|Enable \nPrint\non",
		"bitmap|NO.png,bitmapdn|NO.png,title|Enable \nPrint\noff"
	];
	var i=0;
	// Loops up to length because the very first time reportPOD might not be set!
	for(i=0;i < reportType.length;i++) {
		if(PosCheckParameter("Report","enablePrint",reportType[i])) {
			break;
		}	
	}
	if(i >= reportType.length) {
		i=("true"==change) ? 1 : 0;
	} else {
		if("true"==change) { // Next
			++i;
		}
		if(i >= reportType.length) {
			i=0;
		}
	}
	// either reportPOD was not set or changing from the last to the first...
	PosChangeButtonProperties(0,properties[i]);
	if("true"==change) { // Next
		PosSetParameter("Report","enablePrint",reportType[i]);
	}
	return(true);
} 
 
/**
 * @brief - Check if it has some order with the same major to recall
 */
function PosCheckMultiOrderJS() {
	if(PosCheckSessionProperty("POD","DRIVE_THRU")) {
		return(!PosRecallMultiOrder("true"));
	}
	return(true);
}
/**
*@
*/
function PrintEndOfDayReportsJS(isWay)
{
	var shouldPrint = true; //if is not from the waystation then the close  is done from a POS and we must print the SW report from that POS
	if(isWay == "1") //is from waystation we must check to see if the current pos should print store wide the reports
	{
		var storedbPath=  "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"printEndOfDay\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"printEndOfDay\").@value";
		var result = getConfigValue(storedbPath , posdbPath);
		if(result !="true")
		{
			shouldPrint =false;
		}
	}	
	API.dbg("Endofdayreports: shouldPrint "+shouldPrint);
	/*
	<Section name="EndOfDayReport">
                <Parameter name="CloseReportCashSTW" value="true"/>
                <Parameter name="CloseReportCashSingle" value="true"/>
                <Parameter name="CloseReportPmxSTW" value="true"/>
                <Parameter name="CloseReportPmxSingle" value="true"/>
                <Parameter name="CloseReportHsaSTW" value="true"/>
                <Parameter name="CloseReportHsaSingle" value="true"/>
                <Parameter name="posPrinter"  value="POS004"/> 
            </Section>
	*/
	if(shouldPrint == true) //print store wide report section
	{
		//check to see if we should ignore the printing in case the printer is not available
		var storedbPath=  "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"checkPrinterStatus\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"checkPrinterStatus\").@value";
		var result = getConfigValue(storedbPath , posdbPath) == "true";
		
		
		var printerStatus = PosCheckPrinterStatusJS(true,true);
		if(result ==true && Number(printerStatus)!= 0)
		{
			API.dbg("Try to print store wide end of day repots but encounter printer error "+ printerStatus);
			return true;
		}
		
		var storedbPath=  "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportCashSTW\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportCashSTW\").@value";
		var printReport = getConfigValue(storedbPath , posdbPath);
		if(printReport == "true")
		{
			API.dbg("Endofdayreports: CloseReportCashSTW");
			var result = PosCreateReport("ALL","reportEndDayStoreWide@reports.nps","CONSOLIDATED|NOPREVIEW");
			if( result != true)
			{
				PosShowMessage(API.getLocalMsg("MSG_ENDOFDAYREPORT_CASHSW_FAILED"));
			}
		}
		
		var storedbPath=  "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportPmxSTW\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportPmxSTW\").@value";
		var printReport = getConfigValue(storedbPath , posdbPath);
		if(printReport == "true")
		{
			API.dbg("Endofdayreports: CloseReportPmxSTW");
			var result = PosCreateReport("ALL","reportPMixByDateSW@reports.nps","CONSOLIDATED|NOPREVIEW");
			if( result != true)
			{
				PosShowMessage(API.getLocalMsg("MSG_ENDOFDAYREPORT_PMIXSW_FAILED"));
			}
		}

		var storedbPath=  "Configurations.Configuration.(@type==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportHsaSTW\").@value";
		var posdbPath = "Configuration.(@imports==\"Store.wide\").Section.(@name==\"EndOfDayReport\").Parameter.(@name==\"CloseReportHsaSTW\").@value";
		var printReport = getConfigValue(storedbPath , posdbPath);
		if(printReport == "true")
		{
			API.dbg("Endofdayreports: CloseReportHsaSTW");
			var result = PosCreateReport("ALL","reportSaleHourByDateSW@reports.nps","CONSOLIDATED|NOPREVIEW");
			if( result != true)
			{
				PosShowMessage(API.getLocalMsg("MSG_ENDOFDAYREPORT_HSASW_FAILED"));
			}
		}
	}
	return true;
	
}

/*
* PosDoOrderBumpFromORBJS
*@description: calls a ORBPublisherConsole, weith this conslle it's possible to bump an order from ORB
*@author: Olga Illenseer
*
*@parameter: 	psexecPath			path to the PsExec tool
*									default: D:\\Xptools\\Pstools\\psexec
*				WayName				name or IP address of the PC where the ORBPublisherConsole is located
*				ORBPublisherConsole	Path to the ORBPublisherConsole
*				User				User on the PC where the ORBPublisherConsole is located
*									default: NewPos
*				Password			Password for the user
*									default: Mcdxpe*10
*@return: always true
*/
function PosDoOrderBumpFromORBJS(psexecPath, WayName, ORBPublisherConsole, User, Password)
{
	API.dbg("PosDoOrderBumpFromORBJS: psexecPath: " + psexecPath + " WayName: " + WayName + " ORBPublisherConsole: " + ORBPublisherConsole + "");
	var sOrderID="";
	var hlp = new BusinessObjectHelper;
	
	//var orbcmd = "D:\\Xptools\\Pstools\\psexec \\\\ITR-HEAD-01 "C:\\Program Files\\McDonalds\\ORBPublisherConsole\\McDonalds.Hydra.ORBPublisherConsole.exe "
	
	
	if(psexecPath == null)
	{
		psexecPath = "D:\\Xptools\\Pstools\\psexec";
	}

	/*if(User == null)
	{
		User = "NewPos";
	}
	
	if(Password == null)
	{
		Password = "Mcdxpe*10";
	}*/

	var orbcmd1 = "";

	if(User == null || Password == null)
	{
		orbcmd1 = "\"" + psexecPath + "\"" + " -i " + WayName + " " + "\"" + ORBPublisherConsole + "\"";
	}else
	{
		orbcmd1 = "\"" + psexecPath + "\"" + " -i -u " + User + " -p " + Password + " "  + WayName + " " + "\"" + ORBPublisherConsole + "\"";
	}
	
	// Gets order ID...
	var calculatorText = API.getLocalMsg("MSG_MINI_ORB_BUMP_ORDER_ID");
	if(calculatorText == "MSG_MINI_ORB_BUMP_ORDER_ID")
	{
		calculatorText = "Enter Order ID";
	}
	sOrderID=hlp.showCalculator(calculatorText, "1");
	
	API.dbg("PosDoOrderBumpFromORBJS: sOrderID: " + sOrderID + "");
	
	if(sOrderID.length == 0) {
		return(false);
	} else {
		// Runs OS Command to bump order...
		// PosShowMessage(orbcmd + "+" + sOrderID);
		var command = orbcmd1 + " -" + sOrderID;
		API.dbg("PosDoOrderBumpFromORBJS: command: " + command + "");
		var ret = PosRunOSCommand(command);
		API.dbg("PosDoOrderBumpFromORBJS: ret: " + ret + "");
	}
	return (true);
}

//OI 26.01.2010 add for 6.1.17
/**
* @brief - Check if PROMO button must show
*/
function PosCheckPromoAuthorityJS() {
	var retVal=false;
	var hlp=new BusinessObjectHelper;
	API.dbg("[PosCheckPromoAuthorityJS] PromoItemAuthorityLimits["+hlp.findParamInSectionConfig("PromoItemAuthorityLimits", "UserInterface")+"]");
	if("enable"==hlp.findParamInSectionConfig("PromoItemAuthorityLimits", "UserInterface")) {
		var promoAuthLevel=hlp.findParamInSectionConfig("PromoItemAuthorityLevel", "UserInterface");
		if(""==promoAuthLevel) {
			promoAuthLevel="disable"; // default
		}
		// NPS-5766
		API.dbg("[PosCheckPromoAuthorityJS] PromoItemAuthorityLevel ["+promoAuthLevel+"]");
		if(("crew"==promoAuthLevel)||("manager"==promoAuthLevel)) {
			// show PROMO button for crew and manager
			retVal=true;
		}
	}
	else {
		// compatibility with older version
		retVal=true;
	}
	return(retVal);
}


/**
* @brief - Check if discount authority configuration must show
* returns - returns true to show button or false to not shown
*/
function PosCheckDiscountAuthorityJS() {
	var retVal=false;
	var hlp=new BusinessObjectHelper;
	API.dbg("[PosCheckDiscountAuthorityJS] DiscountAuthorityLimits["+hlp.findParamInSectionConfig("DiscountAuthorityLimits", "UserInterface")+"]");
	if("enable"==hlp.findParamInSectionConfig("DiscountAuthorityLimits", "UserInterface")) {
		var discAuthLevel=hlp.findParamInSectionConfig("DiscountAuthorityLevel", "UserInterface");
		if(""==discAuthLevel) {
			discAuthLevel="manager"; // default
		}
		API.dbg("[PosCheckDiscountAuthorityJS]DiscountAuthorityLevel ["+hlp.findParamInSectionConfig("DiscountAuthorityLevel", "UserInterface")+"]");
		if("none"!=discAuthLevel) {
			retVal=true;
		}
	}
	return(retVal);
}

/**
* @brief - Gets the multiplicity of an item (its quantity times the quantities of its
ancestors)
*/
function lGetProductMultiplicity(view, currentIndex, parentIndex, bLastParent) {
	var iCount;
	var nextLevel=Number(view.ItemView[currentIndex].level)-1;
	var multiplicity=Number(view.ItemView[currentIndex].quantity);
	for(iCount=currentIndex; (iCount>=parentIndex)&&(multiplicity!=0)&&(nextLevel>=0); iCount--) {
		if(view.ItemView[iCount].level==nextLevel) {
			multiplicity=multiplicity*Number(view.ItemView[iCount].quantity);
			nextLevel--;
		}
		if((false==bLastParent)&&(0==nextLevel)) {
			// disconsider the level zero parent
			break;
		}
	}
	return(multiplicity);
}

//OI 27.01.2010 add Fiscal Printer Scripts for 6.1.17

/** Fiscal Printer - X Report
*
* @brief - Execute a X Report in the Fiscal Printer
* Return - rval: true -
*/
function PosFPPrintXReport() {
	var cmd = "PosFPPrintXReport";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	return executeBC(cmd, []);
}

/** Fiscal Printer - Z Report
*
* @brief - Send a Z Report to the Printer
* Return - rval: true -
*/
function PosFPPrintReductionReport() {
	var cmd = "PosFPPrintReductionReport";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	return executeBC(cmd, []);
}

/** Fiscal Printer - PosFPGetInfo
*
* @brief - Return information from Fiscal Printer
* Return - rval: true -
*/
function PosFPGetInfo(info) {
	var cmd = "PosFPGetInfo";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	var hlp = new BusinessObjectHelper;
	var getInfo = hlp.getFPInfo(3);
	PosShowMessage(getInfo);
return;
}

/** Fiscal Printer - PosFPOperation
*
* @brief - Execute directly operations in the Fiscal Printer
* Return - rval: true -
*/
function PosFPOperation(Type,Flags,Param1,Param2,Param3,Param4) {
	var cmd = "PosFPOperation";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	return executeBC(cmd, [Type,Flags,Param1,Param2,Param3,Param4]);
}

/** Fiscal Printer - PosFPGetDateTime
*
* @brief - Get the Fiscal Printer Date and Time
* Return - rval: true -
*/
function PosFPGetDateTime() {
	var cmd = "PosFPGetDateTime";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	var hlp = new BusinessObjectHelper;
	var getInfo = hlp.getFPDateTime();
	PosShowMessage(getInfo);
return;
}

/** Fiscal Printer - PosFPSetDateTime
*
* @brief - Set the Fiscal Printer Date and Time
* Return - rval: true -
*/
function PosFPSetDateTime(DateTime) {
	var cmd = "PosFPSetDateTime";
	CSL_dbglog(7, SRC_BC_SCREEN, cmd, "Start");
	return executeBC(cmd, [DateTime]);
}


/**
 *
 * @brief - This BC totalizes a sale and check if total is correct
 * Return - rval - true if allowed to continue
*/
function PosDoTotalConfirmJS(saleType,screenNumber,screenNumberStore,flags,choices)
{
	var retTot = PosDoTotalJS(saleType,screenNumber,screenNumberStore,flags,choices);
	if( retTot == false ) return false;
	var ctx=new SessionContext;
	
	//Verificar se OrderInProgress
	var checkOrder = PosCheckParameter('OperationMode', 'CheckOrderTotal', 'true');

	checkOrder = checkOrder && (Number(ctx.get("DTStoreMode")) != TANDEM_FACE) && (PosCheckSessionProperty("workingMode","orderTaker") || (PosCheckSessionProperty("workingMode","both") && PosCheckSessionProperty("saleRecalled","false")));

	// Check COD Status
	PosIsCODOnline();
	var is_COD_OnLine = false;
	if (PosCheckSessionProperty("IsCODOnline","1")) {
		is_COD_OnLine = true;
	}

	if( checkOrder && is_COD_OnLine ) {
		var hlp = new BusinessObjectHelper; 
		var curView = hlp.getCurrentView(); 
		if(curView == null) {
			return(true); 
		} 
		var view = new XML(curView); 
		if(null == view) {
			API.dbg("ERROR! XML NULL");
			return(true); 
		}
		
		var total = view.@totalDue;
		var totalFmt = API.formatNumber(total, "###,###,##0.00", 20);
		totalFmt = totalFmt.replace(/^\s*/, "").replace(/\s*$/, "");
		//var retConf = PosShowConfirmationMessage('Is your order correct on the screen ?','Store','Return');
		
		var retConf = PosShowConfirmationMessage('If your order is correct on the screen, your total is $' + totalFmt,'Store','Modify');

		if( retConf ) {
			//Do Store order
			PosDoStoreJS();
		} else {
			//Do modify order / back from total
			PosDoBackFromTotal();
			// SDE-2576
			//PosSetCOD(saleType)
			if( !PosCheckSessionProperty('view','') ) {
				PosCreateReport('VIEW', 'receipt@reports.nps', 'NOPREVIEW|SAVE', '_CASHLESS');
			}
			PosSetSessionProperty('BackFromTotal', 'true');
			PosShowScreen(ctx.get("baseScreenId"));
			PosShowGrillFloatScreen();
		}
	}
	
	return retTot;
}

/*
* This function will check if the received value is null
*/
function PosCheckArgJS(value)
{
	if(value =="" || value == null)
	{
		return false;
	}
	else
	{
		return true;
	}
}

/*
* This function will check if the received value match the current country
value - contains a list of countries separatly by |.
*/
function TestIfCountryJS(value)
{
	var countryList = value.split("|");
	for (i=0; i< countryList.length; i++)
	{
		if(Country == countryList[i].toUpperCase())
		{
			return true;
		}
	}
	return false;
}

/**IsActualSaleQuantityPositive
 *
 * @brief - This BC check if the "ActualSaleQuantity" is positive
 * Return - rval - true if it is positive
 */
function IsActualSaleQuantityPositive()
{
	var ctx=new SessionContext;
	var Qty = ctx.get("ActualSaleQuantity");
	if(Qty > 0) {
		return(true);
	} 
	else {
		return(false);
	}
} 

/*
Author:   Mihai Secareanu
 Description: This function will check if the curently selected product match one defined in the listOfproducts
 listofProducts: list of product separated by |
 Return - true in case of match and false otherwise
*/
function TestSelectedProductCodeJS(listOfProducts)
{
	if(listOfProducts == null || listOfProducts=="")
	{
		return false;
	}
	var hlp = new BusinessObjectHelper;
	var currView = hlp.getCurrentView();
	view= new XML(currView);
	
	var productCodeArray = listOfProducts.split("|");
	for(var i=0 ;i< view.ItemView.length(); i++)
	{
		if(view.ItemView[i].currentSelected == "true")
		{
			var productCode = view.ItemView[i].productCode;
			
			for(var j = 0 ; j< productCodeArray.length; j++)
			{
				//remove  
				productCodeFromList = ltrim(productCodeArray[j]);
				productCodeFromList = rtrim(productCodeFromList);
				API.dbg(productCodeFromList);
				if(productCode == productCodeFromList)
				{
					return true;
				}
			}
			return false;
		}
	}
	return false;
}


/*Author:   Mihai Secareanu
 Description: This function will take a list of product codes (no choices are accepted) will sell the products and promote them
 listofProducts: list of product separated by |
 Return - true 
 */
function SaleProductsAndPromoJS(listOfProducts, listofSkippedAuthProducts)
{
	var productCodeArray = listOfProducts.split("|");
	for(var j = 0 ; j< productCodeArray.length; j++)
	{
		//remove  spaces
		productCodeFromList = ltrim(productCodeArray[j]);
		productCodeFromList = rtrim(productCodeFromList);
		
		//sale the product
		 PosDoTryGrillEnd("3");
		 
		 
		 /* <Step cmd="PosDoTryGrillEnd '3'"/>
		  <Step cmd="PosCheckSessionProperty 'ISPRICEON' 'TRUE'" labelFalse="SALE"/>
		  <Step cmd="PosRefreshButtons"/>
		  <Step cmd="PosShowMenuPriceDialogJS" labelFalse="EXIT"/>
		  <Step label="SALE" cmd="PosDoSaleJS  $ProductCode1"/>
		  
		  */
		 if(PosCheckSessionProperty("ISPRICEON", "TRUE") == true)
		 {	
			PosRefreshButtons();
			if(PosShowMenuPriceDialogJS() == true)
			{
				continue; //nothing to do
			}
		 }
		
		PosDoSaleJS(productCodeFromList);
		PosRefreshSalePanel();
/*
<Step label="CHECKPROD" cmd="TestSelectedProductCodeJS $ProductList" labelTrue="SETSkipAuthorisation" labelFalse="PROMO"/>
		<Step label="SETSkipAuthorisation" cmd="PosSetSessionProperty  'skipPromoAuthorization' 'true'"/>
		<Step label="PROMO" cmd="PosDoPromoItem  $PromoType" labelFalse="ResetSkipAuthorisation" labelTrue="ResetSkipAuthorisation"/>
		<Step label="ResetSkipAuthorisation" cmd="PosSetSessionProperty  'skipPromoAuthorization' 'false'"/>
		
*/		
		if(TestSelectedProductCodeJS(listofSkippedAuthProducts) == true)
		{
			PosSetSessionProperty("skipPromoAuthorization", "true"); //set it to skip authorization
		}
		PosDoPromoItem();
		PosSetSessionProperty("skipPromoAuthorization", "false"); //reset the skip authorization 
	}
	PosDoQuantum("-1");
	return true;
}

// @brief Wrapper for PosClearChoice
//needed because of reduction receipt print 
function PosClearChoiceJS()
{
    // Flaviu 20110505
    //API.DbgMessageBox("PosClearChoiceJS");
    var ctx = new SessionContext;
    ctx.set( "reduction_clear_void_choice", true, false); //this session will delay the print of reduction receipt. It will be printed just form the onClearChoice function 
    return PosClearChoice();
}

// @brief Wrapper for PosDoVoidLine
//needed because of reduction receipt print 
function PosDoVoidLineJS()
{
    // Flaviu 20110505
    //API.DbgMessageBox("PosDoVoidLineJS");
    var ctx = new SessionContext;
    ctx.set( "reduction_clear_void_choice", true, false); //this session will delay the print of reduction receipt. It will be printed just form the onVoidLine function 
    return PosDoVoidLine();
}

/* Author Mihai Secareanu
* Date: 30.05.2011
* Description: This function will toggle between all available foreign and native currency. Is called froma button defined in tender menu
*/
function ToggleCurrencyJS()
{
	if(typeof(arrForeignTenderID) == "undefined")
	{
		arrForeignTenderID = new Array();
		arrForeignTenderID[0] = -1; //last position will reset it to native currency
		// add the foreign tenders
		var foreignTenders = xmlStoreDB.StoreDB.TenderTypes.TenderType.(TenderCategory=="TENDER_FOREIGN_CURRENCY");
		var i=0;
		for(i =0; i < foreignTenders.length(); i++)
		{
			if(foreignTenders[i].@statusCode == "ACTIVE")
			{
				arrForeignTenderID[i+1] = foreignTenders[i].TenderId;
			}
		}
		
		API.dbg("ToggleCurrencyJS "+arrForeignTenderID);
	}
	
	//now toggle the currency
	var ctx = new SessionContext;
	var tenderID = ctx.get("foreignTenderID");
	
	//saerch what is current index in thearrForeignTenderID for the selected value
	var nextTender = 0;
	for(var i=0; i < arrForeignTenderID.length; i++)
	{
		if(arrForeignTenderID[i] == tenderID)
		{
			if((i+1) == arrForeignTenderID.length) //we are at the end of the array, must begin from first position again
			{
				nextTender = arrForeignTenderID[0];
			}
			else //toggle to next available tender
			{
				nextTender = arrForeignTenderID[i+1];
			}
			break;
		}
	}
	
	PosSetForeignCurrency(nextTender);
}

/*
*added for POS Open/Close issue in Ireland
*/
function PosPreOpenDayJS(BusinessDayToOpen) {
    var hlp = new BusinessObjectHelper;
    var xmlPOS=new XML(hlp.getPOSState());
    var state=Number(xmlPOS.@state);
    var bussDate=Number(xmlPOS.@busDate);

    switch(state) {
    case POS_STA_OPLOGGED:
        // fall thru
    case POS_STA_BLOCKOP:
        API.dbg("PosPreOpenDayJS - logged operator day["+bussDate+"] BD to open["+BusinessDayToOpen+"]");
        break;
    case POS_STA_CLOSED:
        API.dbg("PosPreOpenDayJS - already closed["+bussDate+"] BD to open["+BusinessDayToOpen+"]");
        break;
    case POS_STA_OPENED:
        // fall thru
    case POS_STA_BLOCKED:
        if((bussDate!="")&&(BusinessDayToOpen > bussDate)) {
            // not same day -> close
            API.dbg("PosPreOpenDayJS - close day["+bussDate+"] BD to open["+BusinessDayToOpen+"]");
            if(PosEndOfDay ("execute", "remote")) {
                PosCreateReport("ALL", "reportEndOfDay@reports.nps", "NOPREVIEW");
            }
        }
        else {
            API.dbg("PosPreOpenDayJS - keep opened["+bussDate+"] BD to open["+BusinessDayToOpen+"]");
        }
    }
    return (true);
}

/* signed aut version 9-9076
 * authority id = coe
 * authority level = 40
 * authority name = NewPOS COE developer
 * group = npi
 * validity = 2010-04-18
 * signature type = slash_star
 * time stamp (GMT) = Wed Jul 20 13:59:17 2011
 * certificate = 393735312d3739343700dd870dfa88c115e9872a0322c3cbd8b4848e8a384dfe1c7bef38969ec358b1d5f6ff6f0ec062794b2772bb1eeab4bcd19a100010
 * =================================================================================================================================
*/
